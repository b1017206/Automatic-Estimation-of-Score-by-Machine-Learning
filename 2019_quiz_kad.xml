<?xml version="1.0" encoding="UTF-8"?>
<activity id="8600" moduleid="41497" modulename="quiz" contextid="53599">
  <quiz id="8600">
    <name>課題1-1 関数の実装 (木曜)</name>
    <intro></intro>
    <introformat>1</introformat>
    <timeopen>1556171400</timeopen>
    <timeclose>0</timeclose>
    <timelimit>0</timelimit>
    <overduehandling>autoabandon</overduehandling>
    <graceperiod>0</graceperiod>
    <preferredbehaviour>deferredfeedback</preferredbehaviour>
    <canredoquestions>0</canredoquestions>
    <attempts_number>0</attempts_number>
    <attemptonlast>0</attemptonlast>
    <grademethod>1</grademethod>
    <decimalpoints>2</decimalpoints>
    <questiondecimalpoints>-1</questiondecimalpoints>
    <reviewattempt>69888</reviewattempt>
    <reviewcorrectness>4352</reviewcorrectness>
    <reviewmarks>4352</reviewmarks>
    <reviewspecificfeedback>4352</reviewspecificfeedback>
    <reviewgeneralfeedback>4352</reviewgeneralfeedback>
    <reviewrightanswer>0</reviewrightanswer>
    <reviewoverallfeedback>4352</reviewoverallfeedback>
    <questionsperpage>0</questionsperpage>
    <navmethod>free</navmethod>
    <shuffleanswers>1</shuffleanswers>
    <sumgrades>10.00000</sumgrades>
    <grade>10.00000</grade>
    <timecreated>0</timecreated>
    <timemodified>1555397692</timemodified>
    <password></password>
    <subnet></subnet>
    <browsersecurity>-</browsersecurity>
    <delay1>0</delay1>
    <delay2>0</delay2>
    <showuserpicture>0</showuserpicture>
    <showblocks>0</showblocks>
    <completionattemptsexhausted>0</completionattemptsexhausted>
    <completionpass>0</completionpass>
    <allowofflineattempts>0</allowofflineattempts>
    <question_instances>
      <question_instance id="82095">
        <slot>1</slot>
        <page>1</page>
        <requireprevious>0</requireprevious>
        <questionid>219047</questionid>
        <questioncategoryid>$@NULL@$</questioncategoryid>
        <includingsubcategories>$@NULL@$</includingsubcategories>
        <maxmark>10.0000000</maxmark>
        <tags>
        </tags>
      </question_instance>
    </question_instances>
    <sections>
      <section id="8207">
        <firstslot>1</firstslot>
        <heading></heading>
        <shufflequestions>0</shufflequestions>
      </section>
    </sections>
    <feedbacks>
      <feedback id="64901">
        <feedbacktext></feedbacktext>
        <feedbacktextformat>1</feedbacktextformat>
        <mingrade>0.00000</mingrade>
        <maxgrade>11.00000</maxgrade>
      </feedback>
    </feedbacks>
    <overrides>
    </overrides>
    <grades>
      <grade id="700847">
        <userid>3714</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556172868</timemodified>
      </grade>
      <grade id="700848">
        <userid>3248</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174267</timemodified>
      </grade>
      <grade id="700849">
        <userid>3480</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173733</timemodified>
      </grade>
      <grade id="700850">
        <userid>3491</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174376</timemodified>
      </grade>
      <grade id="700851">
        <userid>3567</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176168</timemodified>
      </grade>
      <grade id="700852">
        <userid>3655</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174265</timemodified>
      </grade>
      <grade id="700853">
        <userid>3553</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173148</timemodified>
      </grade>
      <grade id="700854">
        <userid>3728</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175836</timemodified>
      </grade>
      <grade id="700855">
        <userid>3562</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173105</timemodified>
      </grade>
      <grade id="700856">
        <userid>3350</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173508</timemodified>
      </grade>
      <grade id="700857">
        <userid>3610</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176661</timemodified>
      </grade>
      <grade id="700859">
        <userid>3273</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174735</timemodified>
      </grade>
      <grade id="700860">
        <userid>3561</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174702</timemodified>
      </grade>
      <grade id="700861">
        <userid>3524</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556178487</timemodified>
      </grade>
      <grade id="700862">
        <userid>3569</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177133</timemodified>
      </grade>
      <grade id="700863">
        <userid>3701</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174896</timemodified>
      </grade>
      <grade id="700864">
        <userid>3572</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176837</timemodified>
      </grade>
      <grade id="700865">
        <userid>3532</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175271</timemodified>
      </grade>
      <grade id="700866">
        <userid>3492</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174029</timemodified>
      </grade>
      <grade id="700867">
        <userid>3521</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176201</timemodified>
      </grade>
      <grade id="700869">
        <userid>3669</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173434</timemodified>
      </grade>
      <grade id="700871">
        <userid>3681</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556182103</timemodified>
      </grade>
      <grade id="700872">
        <userid>3588</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174181</timemodified>
      </grade>
      <grade id="700874">
        <userid>3582</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175420</timemodified>
      </grade>
      <grade id="700875">
        <userid>3541</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175449</timemodified>
      </grade>
      <grade id="700880">
        <userid>3620</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176256</timemodified>
      </grade>
      <grade id="700882">
        <userid>2233</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174403</timemodified>
      </grade>
      <grade id="700884">
        <userid>3362</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176077</timemodified>
      </grade>
      <grade id="700885">
        <userid>3316</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175817</timemodified>
      </grade>
      <grade id="700887">
        <userid>3584</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556178004</timemodified>
      </grade>
      <grade id="700888">
        <userid>3525</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556174833</timemodified>
      </grade>
      <grade id="700889">
        <userid>3629</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556173905</timemodified>
      </grade>
      <grade id="700891">
        <userid>3552</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177487</timemodified>
      </grade>
      <grade id="700893">
        <userid>3709</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175072</timemodified>
      </grade>
      <grade id="700896">
        <userid>3639</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175943</timemodified>
      </grade>
      <grade id="700897">
        <userid>3726</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176638</timemodified>
      </grade>
      <grade id="700898">
        <userid>3653</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176453</timemodified>
      </grade>
      <grade id="700899">
        <userid>3688</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176262</timemodified>
      </grade>
      <grade id="700901">
        <userid>3674</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176194</timemodified>
      </grade>
      <grade id="700905">
        <userid>3680</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175541</timemodified>
      </grade>
      <grade id="700909">
        <userid>3723</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1557992303</timemodified>
      </grade>
      <grade id="700910">
        <userid>3613</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176030</timemodified>
      </grade>
      <grade id="700912">
        <userid>3605</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177279</timemodified>
      </grade>
      <grade id="700915">
        <userid>3671</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177278</timemodified>
      </grade>
      <grade id="700916">
        <userid>3601</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177186</timemodified>
      </grade>
      <grade id="700917">
        <userid>3661</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176510</timemodified>
      </grade>
      <grade id="700919">
        <userid>3555</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177460</timemodified>
      </grade>
      <grade id="700920">
        <userid>3734</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176992</timemodified>
      </grade>
      <grade id="700922">
        <userid>3708</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177718</timemodified>
      </grade>
      <grade id="700926">
        <userid>3647</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177171</timemodified>
      </grade>
      <grade id="700927">
        <userid>3538</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177431</timemodified>
      </grade>
      <grade id="700930">
        <userid>3696</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177152</timemodified>
      </grade>
      <grade id="700931">
        <userid>3633</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556176114</timemodified>
      </grade>
      <grade id="700933">
        <userid>3678</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556178117</timemodified>
      </grade>
      <grade id="700942">
        <userid>3676</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175656</timemodified>
      </grade>
      <grade id="700943">
        <userid>3563</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177531</timemodified>
      </grade>
      <grade id="700950">
        <userid>3554</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556175997</timemodified>
      </grade>
      <grade id="700956">
        <userid>3130</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556179267</timemodified>
      </grade>
      <grade id="700960">
        <userid>3657</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556182315</timemodified>
      </grade>
      <grade id="700976">
        <userid>3488</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177090</timemodified>
      </grade>
      <grade id="700987">
        <userid>3570</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177766</timemodified>
      </grade>
      <grade id="701001">
        <userid>3550</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177028</timemodified>
      </grade>
      <grade id="701007">
        <userid>3514</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556177984</timemodified>
      </grade>
      <grade id="701031">
        <userid>3141</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556178817</timemodified>
      </grade>
      <grade id="701061">
        <userid>3652</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556178197</timemodified>
      </grade>
      <grade id="701086">
        <userid>3536</userid>
        <gradeval>10.00000</gradeval>
        <timemodified>1556180493</timemodified>
      </grade>
    </grades>
    <attempts>
      <attempt id="1071794">
        <userid>2233</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103092</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173286</timestart>
        <timefinish>1556173689</timefinish>
        <timemodified>1556173689</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103092">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058087">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173691</timemodified>
              <steps>
                <step id="28943319">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173286</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134324</value>
                    </variable>
                  </response>
                </step>
                <step id="28943398">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173687</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3f742433494f070c1e31706ea7457cb7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943401">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173689</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071850">
        <userid>2233</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103148</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174021</timestart>
        <timefinish>1556174030</timefinish>
        <timemodified>1556174030</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103148">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058143">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174032</timemodified>
              <steps>
                <step id="28943476">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174021</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134375</value>
                    </variable>
                  </response>
                </step>
                <step id="28943480">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174028</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d27f6354b20792b46130fde10be79772</value>
                    </variable>
                  </response>
                </step>
                <step id="28943482">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174030</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071886">
        <userid>2233</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103184</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174392</timestart>
        <timefinish>1556174401</timefinish>
        <timemodified>1556174401</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103184">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058271">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174403</timemodified>
              <steps>
                <step id="28943681">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174392</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134402</value>
                    </variable>
                  </response>
                </step>
                <step id="28943684">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174399</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a5e8bf1073550c905aa58618ea6625c0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943686">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174401</timecreated>
                  <userid>2233</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071978">
        <userid>3130</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103276</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175468</timestart>
        <timefinish>1556175965</timefinish>
        <timemodified>1556175965</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103276">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058368">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175967</timemodified>
              <steps>
                <step id="28943984">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175468</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134480</value>
                    </variable>
                  </response>
                </step>
                <step id="28944109">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175963</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5ce837ea0afb3b6c3df367ea13679048</value>
                    </variable>
                  </response>
                </step>
                <step id="28944114">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175965</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072060">
        <userid>3130</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103358</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176317</timestart>
        <timefinish>1556176327</timefinish>
        <timemodified>1556176327</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103358">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058474">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176329</timemodified>
              <steps>
                <step id="28944261">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176317</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134538</value>
                    </variable>
                  </response>
                </step>
                <step id="28944262">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176324</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c6267fadb93741a62ebff7dd2229289c</value>
                    </variable>
                  </response>
                </step>
                <step id="28944266">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176327</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072204">
        <userid>3130</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103502</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177512</timestart>
        <timefinish>1556177523</timefinish>
        <timemodified>1556177523</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103502">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058693">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177525</timemodified>
              <steps>
                <step id="28944845">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177512</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134625</value>
                    </variable>
                  </response>
                </step>
                <step id="28944854">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177521</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7276021bfc2c5896afa39551076160cc</value>
                    </variable>
                  </response>
                </step>
                <step id="28944856">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556177523</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072210">
        <userid>3130</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103508</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177538</timestart>
        <timefinish>1556178998</timefinish>
        <timemodified>1556178998</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103508">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058701">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179000</timemodified>
              <steps>
                <step id="28944868">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177538</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134629</value>
                    </variable>
                  </response>
                </step>
                <step id="28945509">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178994</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>915538ec03ce7aa0c2352321b2f6ce01</value>
                    </variable>
                  </response>
                </step>
                <step id="28945510">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556178998</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072361">
        <userid>3130</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103659</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556179253</timestart>
        <timefinish>1556179264</timefinish>
        <timemodified>1556179264</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103659">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058918">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179267</timemodified>
              <steps>
                <step id="28945590">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179253</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134718</value>
                    </variable>
                  </response>
                </step>
                <step id="28945596">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179262</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5d768a83a37647ece39c9ac684a868cb</value>
                    </variable>
                  </response>
                </step>
                <step id="28945598">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556179264</timecreated>
                  <userid>3130</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072036">
        <userid>3141</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103334</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176121</timestart>
        <timefinish>1556177522</timefinish>
        <timemodified>1556177522</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103334">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058446">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177524</timemodified>
              <steps>
                <step id="28944184">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176121</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134523</value>
                    </variable>
                  </response>
                </step>
                <step id="28944852">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177519</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a95555e6095524d53194dfd8071b3a44</value>
                    </variable>
                  </response>
                </step>
                <step id="28944855">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556177522</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072320">
        <userid>3141</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103618</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556178804</timestart>
        <timefinish>1556178814</timefinish>
        <timemodified>1556178814</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103618">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058868">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556178817</timemodified>
              <steps>
                <step id="28945421">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178804</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134692</value>
                    </variable>
                  </response>
                </step>
                <step id="28945423">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178811</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>904a7c8e2c69d52296e152267051be68</value>
                    </variable>
                  </response>
                </step>
                <step id="28945426">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556178814</timecreated>
                  <userid>3141</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071707">
        <userid>3248</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103005</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171650</timestart>
        <timefinish>1556172291</timefinish>
        <timemodified>1556172291</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103005">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058000">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556172291</timemodified>
              <steps>
                <step id="28943113">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171650</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134242</value>
                    </variable>
                  </response>
                </step>
                <step id="28943138">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172288</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5ee59ff09709c89ed5645b0793692309</value>
                    </variable>
                  </response>
                </step>
                <step id="28943139">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172291</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071723">
        <userid>3248</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103021</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172305</timestart>
        <timefinish>1556172527</timefinish>
        <timemodified>1556172527</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103021">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058016">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172527</timemodified>
              <steps>
                <step id="28943140">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172305</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134257</value>
                    </variable>
                  </response>
                </step>
                <step id="28943168">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172525</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>fde7a5a0932ef82d742580242ec35e72</value>
                    </variable>
                  </response>
                </step>
                <step id="28943169">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172527</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071733">
        <userid>3248</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103031</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172541</timestart>
        <timefinish>1556172675</timefinish>
        <timemodified>1556172675</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103031">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058026">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172677</timemodified>
              <steps>
                <step id="28943170">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172541</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134267</value>
                    </variable>
                  </response>
                </step>
                <step id="28943192">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172673</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b8ba4cebcc828e5a1f306ffc1cac7db6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943193">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172675</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071741">
        <userid>3248</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103039</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172688</timestart>
        <timefinish>1556173095</timefinish>
        <timemodified>1556173095</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103039">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058034">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173097</timemodified>
              <steps>
                <step id="28943194">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172688</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134275</value>
                    </variable>
                  </response>
                </step>
                <step id="28943270">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173092</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f00e553557f09bd602db8668807f41de</value>
                    </variable>
                  </response>
                </step>
                <step id="28943271">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173095</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071766">
        <userid>3248</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103064</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173113</timestart>
        <timefinish>1556174265</timefinish>
        <timemodified>1556174265</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103064">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058059">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174267</timemodified>
              <steps>
                <step id="28943275">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173113</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134298</value>
                    </variable>
                  </response>
                </step>
                <step id="28943633">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174263</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6b0323e84e9c48798dcf9ed280d7c935</value>
                    </variable>
                  </response>
                </step>
                <step id="28943635">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174265</timecreated>
                  <userid>3248</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071703">
        <userid>3273</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103001</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171645</timestart>
        <timefinish>1556172622</timefinish>
        <timemodified>1556172622</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103001">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057996">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172624</timemodified>
              <steps>
                <step id="28943109">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171645</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134238</value>
                    </variable>
                  </response>
                </step>
                <step id="28943172">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172567</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>acf331dd81ae51b52fda409d208c0267</value>
                    </variable>
                  </response>
                </step>
                <step id="28943184">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172622</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071739">
        <userid>3273</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103037</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172650</timestart>
        <timefinish>1556172942</timefinish>
        <timemodified>1556172942</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103037">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058032">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172944</timemodified>
              <steps>
                <step id="28943188">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172650</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134273</value>
                    </variable>
                  </response>
                </step>
                <step id="28943242">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172939</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>75efbe5cb090eb4f25eca26f84695cb2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943244">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172942</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071757">
        <userid>3273</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103055</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172962</timestart>
        <timefinish>1556174733</timefinish>
        <timemodified>1556174733</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103055">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058050">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174735</timemodified>
              <steps>
                <step id="28943246">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172962</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134289</value>
                    </variable>
                  </response>
                </step>
                <step id="28943779">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174730</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>14372b7aed56d84520407f991a007548</value>
                    </variable>
                  </response>
                </step>
                <step id="28943781">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174733</timecreated>
                  <userid>3273</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071770">
        <userid>3316</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103068</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173188</timestart>
        <timefinish>1556173869</timefinish>
        <timemodified>1556173869</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103068">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058063">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173869</timemodified>
              <steps>
                <step id="28943283">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173188</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134301</value>
                    </variable>
                  </response>
                </step>
                <step id="28943424">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173866</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>804af8f3b9a7d721aa8ce2c949b4432c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943426">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173869</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071835">
        <userid>3316</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103133</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173882</timestart>
        <timefinish>1556174064</timefinish>
        <timemodified>1556174064</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103133">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058128">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174064</timemodified>
              <steps>
                <step id="28943430">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173882</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134361</value>
                    </variable>
                  </response>
                </step>
                <step id="28943583">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174060</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b3b6874f472d4a90cea3a1dbebd15d4d</value>
                    </variable>
                  </response>
                </step>
                <step id="28943584">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174064</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071856">
        <userid>3316</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103154</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174074</timestart>
        <timefinish>1556175098</timefinish>
        <timemodified>1556175098</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103154">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058240">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175099</timemodified>
              <steps>
                <step id="28943585">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174074</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134378</value>
                    </variable>
                  </response>
                </step>
                <step id="28943887">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175096</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>cd89bfbc4301e1bd197936b245df5e08</value>
                    </variable>
                  </response>
                </step>
                <step id="28943888">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175098</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071952">
        <userid>3316</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103250</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175112</timestart>
        <timefinish>1556175236</timefinish>
        <timemodified>1556175236</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103250">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058341">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175236</timemodified>
              <steps>
                <step id="28943898">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175112</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134456</value>
                    </variable>
                  </response>
                </step>
                <step id="28943927">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175234</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>50798bf3cab2aae7f4089eccbf3adac6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943928">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175236</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071970">
        <userid>3316</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103268</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175377</timestart>
        <timefinish>1556175396</timefinish>
        <timemodified>1556175396</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103268">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058360">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175398</timemodified>
              <steps>
                <step id="28943956">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175377</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134472</value>
                    </variable>
                  </response>
                </step>
                <step id="28943960">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175393</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ff251bf05bf87046a582bce8cc21d1de</value>
                    </variable>
                  </response>
                </step>
                <step id="28943962">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175396</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071993">
        <userid>3316</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103291</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175805</timestart>
        <timefinish>1556175815</timefinish>
        <timemodified>1556175815</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103291">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058383">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175817</timemodified>
              <steps>
                <step id="28944037">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175805</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134491</value>
                    </variable>
                  </response>
                </step>
                <step id="28944039">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175813</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>39b3b9333b178ea21ad2502481c77abb</value>
                    </variable>
                  </response>
                </step>
                <step id="28944041">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175815</timecreated>
                  <userid>3316</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071691">
        <userid>3350</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102989</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171589</timestart>
        <timefinish>1556172466</timefinish>
        <timemodified>1556172466</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102989">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057984">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172468</timemodified>
              <steps>
                <step id="28943097">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171589</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134226</value>
                    </variable>
                  </response>
                </step>
                <step id="28943165">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172464</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>9193ac8a6893fed0b3ef2107ac2047b5</value>
                    </variable>
                  </response>
                </step>
                <step id="28943166">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172466</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071732">
        <userid>3350</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103030</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172479</timestart>
        <timefinish>1556172583</timefinish>
        <timemodified>1556172583</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103030">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058025">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172585</timemodified>
              <steps>
                <step id="28943167">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172479</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134266</value>
                    </variable>
                  </response>
                </step>
                <step id="28943175">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172580</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a1fc1992406ed8c70303f01449e9377e</value>
                    </variable>
                  </response>
                </step>
                <step id="28943177">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172583</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071736">
        <userid>3350</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103034</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172595</timestart>
        <timefinish>1556172995</timefinish>
        <timemodified>1556172995</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103034">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058029">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172997</timemodified>
              <steps>
                <step id="28943180">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172595</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134270</value>
                    </variable>
                  </response>
                </step>
                <step id="28943250">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172992</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6227e082790da192e3c87762271791d3</value>
                    </variable>
                  </response>
                </step>
                <step id="28943253">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172995</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071762">
        <userid>3350</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103060</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173024</timestart>
        <timefinish>1556173506</timefinish>
        <timemodified>1556173506</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103060">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058055">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173508</timemodified>
              <steps>
                <step id="28943261">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173024</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134294</value>
                    </variable>
                  </response>
                </step>
                <step id="28943355">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173503</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>efa8b58586b4bc500c6e64cb707d1f9c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943357">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173506</timecreated>
                  <userid>3350</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071740">
        <userid>3362</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103038</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172664</timestart>
        <timefinish>1556173864</timefinish>
        <timemodified>1556173864</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103038">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058033">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556173866</timemodified>
              <steps>
                <step id="28943191">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172664</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134274</value>
                    </variable>
                  </response>
                </step>
                <step id="28943423">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173861</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>59d89e3985dc9c14af9a163968ad2874</value>
                    </variable>
                  </response>
                </step>
                <step id="28943425">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173864</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071840">
        <userid>3362</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103138</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173947</timestart>
        <timefinish>1556173956</timefinish>
        <timemodified>1556173956</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103138">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058133">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556173958</timemodified>
              <steps>
                <step id="28943443">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173947</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134366</value>
                    </variable>
                  </response>
                </step>
                <step id="28943445">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173954</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4fa27540a3e2ac159738e826c2571fd3</value>
                    </variable>
                  </response>
                </step>
                <step id="28943447">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173956</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071883">
        <userid>3362</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103181</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174368</timestart>
        <timefinish>1556174375</timefinish>
        <timemodified>1556174375</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103181">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058268">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174377</timemodified>
              <steps>
                <step id="28943667">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174368</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134399</value>
                    </variable>
                  </response>
                </step>
                <step id="28943673">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174374</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>95e46768dd2c526315a7ed7a4ead9ba6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943677">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174375</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072029">
        <userid>3362</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103327</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176064</timestart>
        <timefinish>1556176075</timefinish>
        <timemodified>1556176075</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103327">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058438">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176077</timemodified>
              <steps>
                <step id="28944158">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176064</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134518</value>
                    </variable>
                  </response>
                </step>
                <step id="28944163">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176073</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>69c68cf0178780022386cd971710303e</value>
                    </variable>
                  </response>
                </step>
                <step id="28944165">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176075</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072041">
        <userid>3362</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103339</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>inprogress</state>
        <timestart>1556176157</timestart>
        <timefinish>0</timefinish>
        <timemodified>1556176157</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>$@NULL@$</sumgrades>
        <question_usage id="1103339">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058452">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>$@NULL@$</responsesummary>
              <timemodified>1556176157</timemodified>
              <steps>
                <step id="28944197">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176157</timecreated>
                  <userid>3362</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134525</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071690">
        <userid>3480</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102988</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171512</timestart>
        <timefinish>1556172353</timefinish>
        <timemodified>1556172353</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102988">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057983">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172354</timemodified>
              <steps>
                <step id="28943094">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171512</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134225</value>
                    </variable>
                  </response>
                </step>
                <step id="28943141">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172350</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>958337ae067ea89bd96356cab35c3864</value>
                    </variable>
                  </response>
                </step>
                <step id="28943142">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172353</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071725">
        <userid>3480</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103023</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172371</timestart>
        <timefinish>1556172938</timefinish>
        <timemodified>1556172938</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103023">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058018">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>javaintro.jar</responsesummary>
              <timemodified>1556172940</timemodified>
              <steps>
                <step id="28943150">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172371</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134259</value>
                    </variable>
                  </response>
                </step>
                <step id="28943240">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172935</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>02dc76e05f5aad03d842ad63f4f6fbf0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943243">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172938</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071759">
        <userid>3480</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103057</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172994</timestart>
        <timefinish>1556173001</timefinish>
        <timemodified>1556173001</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103057">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058052">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173003</timemodified>
              <steps>
                <step id="28943252">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172994</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134291</value>
                    </variable>
                  </response>
                </step>
                <step id="28943255">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172998</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b9f3394001047954f78c632e0e29f594</value>
                    </variable>
                  </response>
                </step>
                <step id="28943256">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173001</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071760">
        <userid>3480</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103058</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173016</timestart>
        <timefinish>1556173340</timefinish>
        <timemodified>1556173340</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103058">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058053">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173342</timemodified>
              <steps>
                <step id="28943259">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173016</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134292</value>
                    </variable>
                  </response>
                </step>
                <step id="28943332">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173337</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b682c9255f7f16e24bdb8869110a7169</value>
                    </variable>
                  </response>
                </step>
                <step id="28943333">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173340</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071803">
        <userid>3480</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103101</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173349</timestart>
        <timefinish>1556173731</timefinish>
        <timemodified>1556173731</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103101">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058096">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173733</timemodified>
              <steps>
                <step id="28943337">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173349</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134333</value>
                    </variable>
                  </response>
                </step>
                <step id="28943407">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173729</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>79b5b1f7162f7959c4ce5e7ab717accb</value>
                    </variable>
                  </response>
                </step>
                <step id="28943410">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173731</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071923">
        <userid>3480</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103221</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>inprogress</state>
        <timestart>1556174780</timestart>
        <timefinish>0</timefinish>
        <timemodified>1556174780</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>$@NULL@$</sumgrades>
        <question_usage id="1103221">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058308">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>$@NULL@$</responsesummary>
              <timemodified>1556174780</timemodified>
              <steps>
                <step id="28943796">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174780</timecreated>
                  <userid>3480</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134434</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071925">
        <userid>3488</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103223</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174809</timestart>
        <timefinish>1556176372</timefinish>
        <timemodified>1556176372</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103223">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058310">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176374</timemodified>
              <steps>
                <step id="28943800">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174809</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134436</value>
                    </variable>
                  </response>
                </step>
                <step id="28943988">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175520</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>43885201e5717a98ec6a9ede646ed887</value>
                    </variable>
                  </response>
                </step>
                <step id="28944285">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176372</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072067">
        <userid>3488</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103365</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176380</timestart>
        <timefinish>1556177088</timefinish>
        <timemodified>1556177088</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103365">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058484">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177090</timemodified>
              <steps>
                <step id="28944288">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176380</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134542</value>
                    </variable>
                  </response>
                </step>
                <step id="28944574">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177086</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3f4d080debceb6bcf6e77636e4f1c9fe</value>
                    </variable>
                  </response>
                </step>
                <step id="28944578">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177088</timecreated>
                  <userid>3488</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071692">
        <userid>3491</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102990</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171596</timestart>
        <timefinish>1556172360</timefinish>
        <timemodified>1556172360</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1102990">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057985">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172362</timemodified>
              <steps>
                <step id="28943098">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171596</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134227</value>
                    </variable>
                  </response>
                </step>
                <step id="28943144">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172358</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>053667a705ebf11a42efc412a455e1b5</value>
                    </variable>
                  </response>
                </step>
                <step id="28943146">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172360</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071724">
        <userid>3491</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103022</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172370</timestart>
        <timefinish>1556172857</timefinish>
        <timemodified>1556172857</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103022">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058017">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172859</timemodified>
              <steps>
                <step id="28943149">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172370</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134258</value>
                    </variable>
                  </response>
                </step>
                <step id="28943227">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172855</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2a0e0bc41378a89291b47705f1f0d1d2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943229">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172857</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071753">
        <userid>3491</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103051</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172879</timestart>
        <timefinish>1556172995</timefinish>
        <timemodified>1556172995</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103051">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058046">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172997</timemodified>
              <steps>
                <step id="28943234">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172879</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134286</value>
                    </variable>
                  </response>
                </step>
                <step id="28943251">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172993</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3ccd9cc55c385681ebf621abcf7aeef6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943254">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172995</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071763">
        <userid>3491</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103061</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173025</timestart>
        <timefinish>1556173228</timefinish>
        <timemodified>1556173228</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103061">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058056">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173230</timemodified>
              <steps>
                <step id="28943262">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173025</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134295</value>
                    </variable>
                  </response>
                </step>
                <step id="28943288">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173226</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3f4a07c32b2bc76287100463fa8e3b09</value>
                    </variable>
                  </response>
                </step>
                <step id="28943292">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173228</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071775">
        <userid>3491</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103073</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173236</timestart>
        <timefinish>1556174374</timefinish>
        <timemodified>1556174374</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103073">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058068">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174376</timemodified>
              <steps>
                <step id="28943295">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173236</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134306</value>
                    </variable>
                  </response>
                </step>
                <step id="28943672">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174372</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>9a17f80acc9f4f32f0db74bef8054fa4</value>
                    </variable>
                  </response>
                </step>
                <step id="28943676">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174374</timecreated>
                  <userid>3491</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071694">
        <userid>3492</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102992</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171610</timestart>
        <timefinish>1556172775</timefinish>
        <timemodified>1556172775</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1102992">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057987">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172777</timemodified>
              <steps>
                <step id="28943100">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171610</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134229</value>
                    </variable>
                  </response>
                </step>
                <step id="28943218">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172772</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ce8c4e683d15374f54c09bf48b887e70</value>
                    </variable>
                  </response>
                </step>
                <step id="28943220">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172775</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071849">
        <userid>3492</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103147</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174019</timestart>
        <timefinish>1556174026</timefinish>
        <timemodified>1556174026</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103147">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058142">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174029</timemodified>
              <steps>
                <step id="28943474">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174019</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134374</value>
                    </variable>
                  </response>
                </step>
                <step id="28943478">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174024</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>917464c5c78aeb8f3c72cd45acd34089</value>
                    </variable>
                  </response>
                </step>
                <step id="28943481">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174026</timecreated>
                  <userid>3492</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071783">
        <userid>3514</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103081</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173259</timestart>
        <timefinish>1556177167</timefinish>
        <timemodified>1556177167</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103081">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058076">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177167</timemodified>
              <steps>
                <step id="28943305">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173259</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134313</value>
                    </variable>
                  </response>
                </step>
                <step id="28943586">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174078</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b88fb4e09cff62598255db534f564223</value>
                    </variable>
                  </response>
                </step>
                <step id="28944650">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177161</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a3ea001c277e922391288218ebc28f82</value>
                    </variable>
                  </response>
                </step>
                <step id="28944652">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556177167</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072165">
        <userid>3514</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103463</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177261</timestart>
        <timefinish>1556177274</timefinish>
        <timemodified>1556177274</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103463">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058652">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177276</timemodified>
              <steps>
                <step id="28944702">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177261</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134598</value>
                    </variable>
                  </response>
                </step>
                <step id="28944710">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177268</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f6342b607ab523d1e31285e0caf25887</value>
                    </variable>
                  </response>
                </step>
                <step id="28944714">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556177274</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072180">
        <userid>3514</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103478</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177349</timestart>
        <timefinish>1556177357</timefinish>
        <timemodified>1556177357</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103478">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058668">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556177359</timemodified>
              <steps>
                <step id="28944754">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177349</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134609</value>
                    </variable>
                  </response>
                </step>
                <step id="28944772">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177355</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>dc1f9daf0c8ea5e1eaddd795b604b9d9</value>
                    </variable>
                  </response>
                </step>
                <step id="28944776">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556177357</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072188">
        <userid>3514</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103486</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177414</timestart>
        <timefinish>1556177982</timefinish>
        <timemodified>1556177982</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103486">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058676">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556177984</timemodified>
              <steps>
                <step id="28944796">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177414</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134614</value>
                    </variable>
                  </response>
                </step>
                <step id="28945031">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177979</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8cc3b44da5054b3eb97a243cfedf7858</value>
                    </variable>
                  </response>
                </step>
                <step id="28945032">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177982</timecreated>
                  <userid>3514</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071701">
        <userid>3521</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102999</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171644</timestart>
        <timefinish>1556172973</timefinish>
        <timemodified>1556172973</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102999">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057994">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>javaintro3.jar</responsesummary>
              <timemodified>1556172975</timemodified>
              <steps>
                <step id="28943107">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171644</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134236</value>
                    </variable>
                  </response>
                </step>
                <step id="28943248">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172970</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>78c625354353e3d8eca8286a21b1128c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943249">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172973</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071761">
        <userid>3521</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103059</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173018</timestart>
        <timefinish>1556173130</timefinish>
        <timemodified>1556173130</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103059">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058054">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173132</timemodified>
              <steps>
                <step id="28943260">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173018</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134293</value>
                    </variable>
                  </response>
                </step>
                <step id="28943276">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173128</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>83753519300adb1ac1d29d27662a334b</value>
                    </variable>
                  </response>
                </step>
                <step id="28943277">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173130</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071767">
        <userid>3521</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103065</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173155</timestart>
        <timefinish>1556173848</timefinish>
        <timemodified>1556173848</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103065">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058060">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173850</timemodified>
              <steps>
                <step id="28943280">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173155</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134299</value>
                    </variable>
                  </response>
                </step>
                <step id="28943420">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173842</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ef9a712747f169bf105d819cef2dc509</value>
                    </variable>
                  </response>
                </step>
                <step id="28943422">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173848</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071834">
        <userid>3521</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103132</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173880</timestart>
        <timefinish>1556176198</timefinish>
        <timemodified>1556176198</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103132">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058127">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176201</timemodified>
              <steps>
                <step id="28943429">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173880</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134360</value>
                    </variable>
                  </response>
                </step>
                <step id="28944218">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176196</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>67f0373b5cde7cffcdb56c918f320375</value>
                    </variable>
                  </response>
                </step>
                <step id="28944220">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176198</timecreated>
                  <userid>3521</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071713">
        <userid>3524</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103011</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171656</timestart>
        <timefinish>1556172704</timefinish>
        <timemodified>1556172704</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103011">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058006">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556172705</timemodified>
              <steps>
                <step id="28943119">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171656</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134248</value>
                    </variable>
                  </response>
                </step>
                <step id="28943195">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172701</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>42e204012aad40a11cb9b78242e6a035</value>
                    </variable>
                  </response>
                </step>
                <step id="28943196">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172704</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071742">
        <userid>3524</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103040</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172715</timestart>
        <timefinish>1556175052</timefinish>
        <timemodified>1556175052</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103040">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058035">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175054</timemodified>
              <steps>
                <step id="28943198">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172715</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134276</value>
                    </variable>
                  </response>
                </step>
                <step id="28943873">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175049</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>cf4e310066ea0f2f028bbf08d83402e7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943874">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175052</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071948">
        <userid>3524</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103246</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175062</timestart>
        <timefinish>1556175895</timefinish>
        <timemodified>1556175895</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103246">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058337">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175897</timemodified>
              <steps>
                <step id="28943876">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175062</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134453</value>
                    </variable>
                  </response>
                </step>
                <step id="28944083">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175893</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>cf4e310066ea0f2f028bbf08d83402e7</value>
                    </variable>
                  </response>
                </step>
                <step id="28944087">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175895</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072009">
        <userid>3524</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103307</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175919</timestart>
        <timefinish>1556176949</timefinish>
        <timemodified>1556176949</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103307">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058412">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176951</timemodified>
              <steps>
                <step id="28944096">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175919</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134504</value>
                    </variable>
                  </response>
                </step>
                <step id="28944517">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176947</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>cf4e310066ea0f2f028bbf08d83402e7</value>
                    </variable>
                  </response>
                </step>
                <step id="28944519">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176949</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072124">
        <userid>3524</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103422</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176969</timestart>
        <timefinish>1556177761</timefinish>
        <timemodified>1556177761</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103422">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058572">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177763</timemodified>
              <steps>
                <step id="28944525">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176969</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134578</value>
                    </variable>
                  </response>
                </step>
                <step id="28944950">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177758</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>db90063b57a2cb4baf3182cce875af6c</value>
                    </variable>
                  </response>
                </step>
                <step id="28944952">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556177761</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072234">
        <userid>3524</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103532</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177772</timestart>
        <timefinish>1556178485</timefinish>
        <timemodified>1556178485</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103532">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058731">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556178487</timemodified>
              <steps>
                <step id="28944955">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177772</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134643</value>
                    </variable>
                  </response>
                </step>
                <step id="28945263">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178483</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>aa2b9875ce777a8edef4d841a1f9cef7</value>
                    </variable>
                  </response>
                </step>
                <step id="28945265">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556178485</timecreated>
                  <userid>3524</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071790">
        <userid>3525</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103088</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173282</timestart>
        <timefinish>1556173896</timefinish>
        <timemodified>1556173896</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103088">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058083">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173898</timemodified>
              <steps>
                <step id="28943315">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173282</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134320</value>
                    </variable>
                  </response>
                </step>
                <step id="28943434">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173894</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>fc95f0f2d3c051a4c41bc4ad0c8f8f21</value>
                    </variable>
                  </response>
                </step>
                <step id="28943436">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173896</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071839">
        <userid>3525</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103137</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173906</timestart>
        <timefinish>1556174369</timefinish>
        <timemodified>1556174369</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103137">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058132">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174371</timemodified>
              <steps>
                <step id="28943441">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173906</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134365</value>
                    </variable>
                  </response>
                </step>
                <step id="28943666">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174367</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f1eac9befc26459fe48a76daa0fec152</value>
                    </variable>
                  </response>
                </step>
                <step id="28943671">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174369</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071885">
        <userid>3525</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103183</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174383</timestart>
        <timefinish>1556174831</timefinish>
        <timemodified>1556174831</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103183">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058270">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174833</timemodified>
              <steps>
                <step id="28943679">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174383</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134401</value>
                    </variable>
                  </response>
                </step>
                <step id="28943803">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174829</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>147a8e9a07ae9956ff3454e956378ae2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943805">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174831</timecreated>
                  <userid>3525</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071705">
        <userid>3532</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103003</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171648</timestart>
        <timefinish>1556172743</timefinish>
        <timemodified>1556172743</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103003">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057998">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172745</timemodified>
              <steps>
                <step id="28943111">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171648</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134240</value>
                    </variable>
                  </response>
                </step>
                <step id="28943210">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172740</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>543a96efc01233f7d76e979ba4bc4839</value>
                    </variable>
                  </response>
                </step>
                <step id="28943212">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172743</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071752">
        <userid>3532</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103050</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172851</timestart>
        <timefinish>1556172861</timefinish>
        <timemodified>1556172861</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103050">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058045">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172863</timemodified>
              <steps>
                <step id="28943225">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172851</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134285</value>
                    </variable>
                  </response>
                </step>
                <step id="28943230">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172859</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7b170eb0111014412c7a7540ee02c25c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943231">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172861</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071755">
        <userid>3532</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103053</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172916</timestart>
        <timefinish>1556172925</timefinish>
        <timemodified>1556172925</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103053">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058048">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172927</timemodified>
              <steps>
                <step id="28943236">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172916</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134287</value>
                    </variable>
                  </response>
                </step>
                <step id="28943237">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172923</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f1f5111e50a891d02d57fe0fe4acae71</value>
                    </variable>
                  </response>
                </step>
                <step id="28943238">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172925</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071758">
        <userid>3532</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103056</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172965</timestart>
        <timefinish>1556173391</timefinish>
        <timemodified>1556173391</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103056">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058051">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173393</timemodified>
              <steps>
                <step id="28943247">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172965</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134290</value>
                    </variable>
                  </response>
                </step>
                <step id="28943340">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173388</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e655f8cfa2c70d074984b736706c2b94</value>
                    </variable>
                  </response>
                </step>
                <step id="28943341">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173391</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071807">
        <userid>3532</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103105</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173421</timestart>
        <timefinish>1556173513</timefinish>
        <timemodified>1556173513</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103105">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058100">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173515</timemodified>
              <steps>
                <step id="28943344">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173421</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134336</value>
                    </variable>
                  </response>
                </step>
                <step id="28943359">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173511</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0d2cdcf5b1a7ec014fe4aab260449a37</value>
                    </variable>
                  </response>
                </step>
                <step id="28943361">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173513</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071819">
        <userid>3532</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103117</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173600</timestart>
        <timefinish>1556173608</timefinish>
        <timemodified>1556173608</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103117">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058112">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173610</timemodified>
              <steps>
                <step id="28943376">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173600</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134346</value>
                    </variable>
                  </response>
                </step>
                <step id="28943379">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173606</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>265fffb8efce7e118b4b941c084d9533</value>
                    </variable>
                  </response>
                </step>
                <step id="28943381">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173608</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071826">
        <userid>3532</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103124</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173673</timestart>
        <timefinish>1556173681</timefinish>
        <timemodified>1556173681</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103124">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058119">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173683</timemodified>
              <steps>
                <step id="28943393">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173673</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134353</value>
                    </variable>
                  </response>
                </step>
                <step id="28943396">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173679</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3dfc51340b61324e814717bd60d24d87</value>
                    </variable>
                  </response>
                </step>
                <step id="28943397">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173681</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071829">
        <userid>3532</userid>
        <attemptnum>8</attemptnum>
        <uniqueid>1103127</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173729</timestart>
        <timefinish>1556173735</timefinish>
        <timemodified>1556173735</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103127">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058122">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173738</timemodified>
              <steps>
                <step id="28943408">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173729</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134356</value>
                    </variable>
                  </response>
                </step>
                <step id="28943411">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173733</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7b4997e76eebe2002a7e573800de3731</value>
                    </variable>
                  </response>
                </step>
                <step id="28943412">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173735</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071871">
        <userid>3532</userid>
        <attemptnum>9</attemptnum>
        <uniqueid>1103169</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174245</timestart>
        <timefinish>1556174255</timefinish>
        <timemodified>1556174255</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103169">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058256">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174257</timemodified>
              <steps>
                <step id="28943627">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174245</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134391</value>
                    </variable>
                  </response>
                </step>
                <step id="28943629">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174253</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>04cbb34a4ee9ced611a8676d77cd9729</value>
                    </variable>
                  </response>
                </step>
                <step id="28943631">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174255</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071904">
        <userid>3532</userid>
        <attemptnum>10</attemptnum>
        <uniqueid>1103202</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174588</timestart>
        <timefinish>1556174673</timefinish>
        <timemodified>1556174673</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103202">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058289">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174675</timemodified>
              <steps>
                <step id="28943733">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174588</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134417</value>
                    </variable>
                  </response>
                </step>
                <step id="28943766">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174671</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0d973498ddb0e93c9ec5eb8fdd48fe96</value>
                    </variable>
                  </response>
                </step>
                <step id="28943767">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174673</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071963">
        <userid>3532</userid>
        <attemptnum>11</attemptnum>
        <uniqueid>1103261</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175261</timestart>
        <timefinish>1556175269</timefinish>
        <timemodified>1556175269</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103261">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058353">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175271</timemodified>
              <steps>
                <step id="28943932">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175261</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134465</value>
                    </variable>
                  </response>
                </step>
                <step id="28943933">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175267</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>94f5432ee74f5548c05e563999121d5c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943935">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175269</timecreated>
                  <userid>3532</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072100">
        <userid>3536</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103398</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176730</timestart>
        <timefinish>1556179070</timefinish>
        <timemodified>1556179070</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103398">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058524">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179072</timemodified>
              <steps>
                <step id="28944405">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176730</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134563</value>
                    </variable>
                  </response>
                </step>
                <step id="28945523">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179065</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d6fb5857710879e37dcfd64eba682e3a</value>
                    </variable>
                  </response>
                </step>
                <step id="28945530">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556179070</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072419">
        <userid>3536</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103717</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556179784</timestart>
        <timefinish>1556179797</timefinish>
        <timemodified>1556179797</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103717">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059000">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179799</timemodified>
              <steps>
                <step id="28945821">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179784</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134745</value>
                    </variable>
                  </response>
                </step>
                <step id="28945825">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179794</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4c0218795f6d744932b0d8c78ccc5b02</value>
                    </variable>
                  </response>
                </step>
                <step id="28945828">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556179797</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072475">
        <userid>3536</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103773</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180468</timestart>
        <timefinish>1556180491</timefinish>
        <timemodified>1556180491</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103773">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059084">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180493</timemodified>
              <steps>
                <step id="28946069">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180468</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134759</value>
                    </variable>
                  </response>
                </step>
                <step id="28946075">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180487</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ad240e83bb9209c7a310df2ebc01550f</value>
                    </variable>
                  </response>
                </step>
                <step id="28946078">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556180491</timecreated>
                  <userid>3536</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071784">
        <userid>3538</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103082</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173267</timestart>
        <timefinish>1556175001</timefinish>
        <timemodified>1556175001</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103082">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058077">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175003</timemodified>
              <steps>
                <step id="28943307">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173267</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134314</value>
                    </variable>
                  </response>
                </step>
                <step id="28943847">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174997</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d8725a9e35388b5a06e77fd1e9e74e2d</value>
                    </variable>
                  </response>
                </step>
                <step id="28943850">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175001</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071960">
        <userid>3538</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103258</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175192</timestart>
        <timefinish>1556175205</timefinish>
        <timemodified>1556175205</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103258">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058350">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175207</timemodified>
              <steps>
                <step id="28943923">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175192</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134463</value>
                    </variable>
                  </response>
                </step>
                <step id="28943925">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175202</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>21c9a1f1e3aa392d28aedb9a2e204271</value>
                    </variable>
                  </response>
                </step>
                <step id="28943926">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175205</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071985">
        <userid>3538</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103283</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175656</timestart>
        <timefinish>1556175673</timefinish>
        <timemodified>1556175673</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103283">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058375">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175675</timemodified>
              <steps>
                <step id="28944005">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175656</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134484</value>
                    </variable>
                  </response>
                </step>
                <step id="28944010">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175670</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>06d4ebdcc3ff021473c146bee319d414</value>
                    </variable>
                  </response>
                </step>
                <step id="28944015">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175673</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071995">
        <userid>3538</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103293</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175828</timestart>
        <timefinish>1556175843</timefinish>
        <timemodified>1556175843</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103293">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058385">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175845</timemodified>
              <steps>
                <step id="28944045">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175828</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134493</value>
                    </variable>
                  </response>
                </step>
                <step id="28944053">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175840</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7b12ffe6206f40001a36f2d7d8ba8513</value>
                    </variable>
                  </response>
                </step>
                <step id="28944054">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175843</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072002">
        <userid>3538</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103300</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175892</timestart>
        <timefinish>1556175906</timefinish>
        <timemodified>1556175906</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103300">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058392">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175908</timemodified>
              <steps>
                <step id="28944069">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175892</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134499</value>
                    </variable>
                  </response>
                </step>
                <step id="28944089">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175903</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>00ee0feab5a9ed9b81efea5f50ed4ad4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944093">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175906</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072025">
        <userid>3538</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103323</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176051</timestart>
        <timefinish>1556176063</timefinish>
        <timemodified>1556176063</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103323">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058434">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176065</timemodified>
              <steps>
                <step id="28944152">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176051</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134514</value>
                    </variable>
                  </response>
                </step>
                <step id="28944156">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176060</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8ab63f012c36f81ae9480e86ab177281</value>
                    </variable>
                  </response>
                </step>
                <step id="28944159">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176063</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072038">
        <userid>3538</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103336</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176137</timestart>
        <timefinish>1556176148</timefinish>
        <timemodified>1556176148</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103336">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058448">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176150</timemodified>
              <steps>
                <step id="28944189">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176137</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134524</value>
                    </variable>
                  </response>
                </step>
                <step id="28944194">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176146</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>883d5109cd228a0ba8bfc85395137135</value>
                    </variable>
                  </response>
                </step>
                <step id="28944195">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176148</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072078">
        <userid>3538</userid>
        <attemptnum>8</attemptnum>
        <uniqueid>1103376</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176439</timestart>
        <timefinish>1556176449</timefinish>
        <timemodified>1556176449</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103376">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058498">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176451</timemodified>
              <steps>
                <step id="28944319">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176439</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134548</value>
                    </variable>
                  </response>
                </step>
                <step id="28944323">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176447</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>758103029544a3eafa32ef58d32f0c80</value>
                    </variable>
                  </response>
                </step>
                <step id="28944326">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556176449</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072191">
        <userid>3538</userid>
        <attemptnum>9</attemptnum>
        <uniqueid>1103489</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177419</timestart>
        <timefinish>1556177429</timefinish>
        <timemodified>1556177429</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103489">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058679">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177431</timemodified>
              <steps>
                <step id="28944799">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177419</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134617</value>
                    </variable>
                  </response>
                </step>
                <step id="28944804">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177427</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3f7a1a097e69c8e1e9751bc583aeac38</value>
                    </variable>
                  </response>
                </step>
                <step id="28944808">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177429</timecreated>
                  <userid>3538</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071686">
        <userid>3541</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102984</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171409</timestart>
        <timefinish>1556173420</timefinish>
        <timemodified>1556173420</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102984">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057979">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173421</timemodified>
              <steps>
                <step id="28943089">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171409</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134221</value>
                    </variable>
                  </response>
                </step>
                <step id="28943343">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173417</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>91282300b2f629d1ebc21e9c28aeaa60</value>
                    </variable>
                  </response>
                </step>
                <step id="28943345">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173420</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071815">
        <userid>3541</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103113</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173563</timestart>
        <timefinish>1556173580</timefinish>
        <timemodified>1556173580</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103113">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058108">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173582</timemodified>
              <steps>
                <step id="28943368">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173563</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134342</value>
                    </variable>
                  </response>
                </step>
                <step id="28943372">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173578</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>319fb80d0599c5585805dd20252f7530</value>
                    </variable>
                  </response>
                </step>
                <step id="28943374">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173580</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071820">
        <userid>3541</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103118</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173604</timestart>
        <timefinish>1556174161</timefinish>
        <timemodified>1556174161</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103118">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058113">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174164</timemodified>
              <steps>
                <step id="28943377">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173604</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134347</value>
                    </variable>
                  </response>
                </step>
                <step id="28943603">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174159</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>94be5d5b27f3cf5411b883e2c5ff09e8</value>
                    </variable>
                  </response>
                </step>
                <step id="28943604">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174161</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071863">
        <userid>3541</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103161</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174176</timestart>
        <timefinish>1556174577</timefinish>
        <timemodified>1556174577</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103161">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058248">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174579</timemodified>
              <steps>
                <step id="28943606">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174176</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134384</value>
                    </variable>
                  </response>
                </step>
                <step id="28943728">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174575</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>78ff9585b2d5c5157d422254980bcd48</value>
                    </variable>
                  </response>
                </step>
                <step id="28943730">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174577</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071903">
        <userid>3541</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103201</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174587</timestart>
        <timefinish>1556174908</timefinish>
        <timemodified>1556174908</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103201">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058288">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174910</timemodified>
              <steps>
                <step id="28943731">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174587</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134416</value>
                    </variable>
                  </response>
                </step>
                <step id="28943827">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174905</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>39a90549c66813a6f8e2905a80917373</value>
                    </variable>
                  </response>
                </step>
                <step id="28943829">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174908</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071936">
        <userid>3541</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103234</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174931</timestart>
        <timefinish>1556174950</timefinish>
        <timemodified>1556174950</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103234">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058321">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174952</timemodified>
              <steps>
                <step id="28943835">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174931</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134444</value>
                    </variable>
                  </response>
                </step>
                <step id="28943837">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174948</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>39a90549c66813a6f8e2905a80917373</value>
                    </variable>
                  </response>
                </step>
                <step id="28943838">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174950</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071957">
        <userid>3541</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103255</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175155</timestart>
        <timefinish>1556175175</timefinish>
        <timemodified>1556175175</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103255">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058346">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175177</timemodified>
              <steps>
                <step id="28943910">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175155</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134461</value>
                    </variable>
                  </response>
                </step>
                <step id="28943914">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175172</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>23f47995851328fdeefbd5b752fd2723</value>
                    </variable>
                  </response>
                </step>
                <step id="28943919">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175175</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071974">
        <userid>3541</userid>
        <attemptnum>8</attemptnum>
        <uniqueid>1103272</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175434</timestart>
        <timefinish>1556175447</timefinish>
        <timemodified>1556175447</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103272">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058364">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175449</timemodified>
              <steps>
                <step id="28943974">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175434</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134476</value>
                    </variable>
                  </response>
                </step>
                <step id="28943976">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175444</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>54856e2cad2f36c6ec601cd78ca697f5</value>
                    </variable>
                  </response>
                </step>
                <step id="28943979">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175447</timecreated>
                  <userid>3541</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071695">
        <userid>3550</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102993</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171637</timestart>
        <timefinish>1556177026</timefinish>
        <timemodified>1556177026</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1102993">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057988">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177028</timemodified>
              <steps>
                <step id="28943101">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171637</timecreated>
                  <userid>3550</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134230</value>
                    </variable>
                  </response>
                </step>
                <step id="28943367">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173556</timecreated>
                  <userid>3550</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>441ba4f7ee692c317b6a1904b0a224c1</value>
                    </variable>
                  </response>
                </step>
                <step id="28944547">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177023</timecreated>
                  <userid>3550</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>536ffd37e0bed283b0eb72fd7aae54c4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944549">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177026</timecreated>
                  <userid>3550</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071774">
        <userid>3552</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103072</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173231</timestart>
        <timefinish>1556173974</timefinish>
        <timemodified>1556173974</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103072">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058067">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173976</timemodified>
              <steps>
                <step id="28943293">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173231</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134305</value>
                    </variable>
                  </response>
                </step>
                <step id="28943321">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173306</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value></value>
                    </variable>
                  </response>
                </step>
                <step id="28943453">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173970</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8f518c81b774fbbb189960c567042913</value>
                    </variable>
                  </response>
                </step>
                <step id="28943454">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173974</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071847">
        <userid>3552</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103145</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174000</timestart>
        <timefinish>1556174540</timefinish>
        <timemodified>1556174540</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103145">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058140">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174542</timemodified>
              <steps>
                <step id="28943466">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174000</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134372</value>
                    </variable>
                  </response>
                </step>
                <step id="28943716">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174537</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3d29604d2173f28fdd46731c3c565988</value>
                    </variable>
                  </response>
                </step>
                <step id="28943717">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174540</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071902">
        <userid>3552</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103200</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174552</timestart>
        <timefinish>1556177076</timefinish>
        <timemodified>1556177076</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103200">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058287">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177078</timemodified>
              <steps>
                <step id="28943720">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174552</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134415</value>
                    </variable>
                  </response>
                </step>
                <step id="28944562">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177074</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bb094dfa99de6fb77230755ec87a0e06</value>
                    </variable>
                  </response>
                </step>
                <step id="28944565">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556177076</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072138">
        <userid>3552</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103436</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177087</timestart>
        <timefinish>1556177192</timefinish>
        <timemodified>1556177192</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103436">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058588">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177194</timemodified>
              <steps>
                <step id="28944575">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177087</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134585</value>
                    </variable>
                  </response>
                </step>
                <step id="28944665">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177190</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>77fd242ced616863da35741257f25b7e</value>
                    </variable>
                  </response>
                </step>
                <step id="28944667">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556177192</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072156">
        <userid>3552</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103454</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177219</timestart>
        <timefinish>1556177485</timefinish>
        <timemodified>1556177485</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103454">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058641">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177487</timemodified>
              <steps>
                <step id="28944674">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177219</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134594</value>
                    </variable>
                  </response>
                </step>
                <step id="28944813">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177453</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value></value>
                    </variable>
                  </response>
                </step>
                <step id="28944829">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177483</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1a7742d932631cda8ae6828f2566957e</value>
                    </variable>
                  </response>
                </step>
                <step id="28944831">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177485</timecreated>
                  <userid>3552</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071689">
        <userid>3553</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102987</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171490</timestart>
        <timefinish>1556172433</timefinish>
        <timemodified>1556172433</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1102987">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057982">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exerdise1a.jar</responsesummary>
              <timemodified>1556172435</timemodified>
              <steps>
                <step id="28943093">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171490</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134224</value>
                    </variable>
                  </response>
                </step>
                <step id="28943156">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172430</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>618d9ec17eca74ac28b3f7cb9564c23a</value>
                    </variable>
                  </response>
                </step>
                <step id="28943157">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172433</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071729">
        <userid>3553</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103027</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172448</timestart>
        <timefinish>1556172935</timefinish>
        <timemodified>1556172935</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103027">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058022">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exerdise1a.jar</responsesummary>
              <timemodified>1556172937</timemodified>
              <steps>
                <step id="28943161">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172448</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134263</value>
                    </variable>
                  </response>
                </step>
                <step id="28943239">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172932</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d37c56a1b4901ca1ec7ab683994ca3ad</value>
                    </variable>
                  </response>
                </step>
                <step id="28943241">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172935</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071756">
        <userid>3553</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103054</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172946</timestart>
        <timefinish>1556173146</timefinish>
        <timemodified>1556173146</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103054">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058049">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exerdise1a.jar</responsesummary>
              <timemodified>1556173148</timemodified>
              <steps>
                <step id="28943245">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172946</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134288</value>
                    </variable>
                  </response>
                </step>
                <step id="28943278">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173144</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>50d757c283c20323c0f43915663c9ea2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943279">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173146</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071771">
        <userid>3553</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103069</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>inprogress</state>
        <timestart>1556173193</timestart>
        <timefinish>0</timefinish>
        <timemodified>1556173193</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>$@NULL@$</sumgrades>
        <question_usage id="1103069">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058064">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>$@NULL@$</responsesummary>
              <timemodified>1556173193</timemodified>
              <steps>
                <step id="28943284">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173193</timecreated>
                  <userid>3553</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134302</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071711">
        <userid>3554</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103009</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171654</timestart>
        <timefinish>1556175752</timefinish>
        <timemodified>1556175752</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103009">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058004">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175752</timemodified>
              <steps>
                <step id="28943117">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171654</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134246</value>
                    </variable>
                  </response>
                </step>
                <step id="28944029">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175748</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0130f909b043c2f2c853919e7ef9dfff</value>
                    </variable>
                  </response>
                </step>
                <step id="28944030">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175752</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072006">
        <userid>3554</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103304</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175905</timestart>
        <timefinish>1556175995</timefinish>
        <timemodified>1556175995</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103304">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058409">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175997</timemodified>
              <steps>
                <step id="28944091">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175905</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134501</value>
                    </variable>
                  </response>
                </step>
                <step id="28944127">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175992</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>9011c5c392f999a638d1453126ffe0ab</value>
                    </variable>
                  </response>
                </step>
                <step id="28944130">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175995</timecreated>
                  <userid>3554</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071798">
        <userid>3555</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103096</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173316</timestart>
        <timefinish>1556174661</timefinish>
        <timemodified>1556174661</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103096">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058091">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174662</timemodified>
              <steps>
                <step id="28943326">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173316</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134328</value>
                    </variable>
                  </response>
                </step>
                <step id="28943759">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174650</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8562e1a05549705d8d9e41dae0fc1cb1</value>
                    </variable>
                  </response>
                </step>
                <step id="28943764">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174661</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071987">
        <userid>3555</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103285</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175661</timestart>
        <timefinish>1556175678</timefinish>
        <timemodified>1556175678</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103285">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058377">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175680</timemodified>
              <steps>
                <step id="28944007">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175661</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134486</value>
                    </variable>
                  </response>
                </step>
                <step id="28944014">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175675</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>02307b543576c98ce243bd9d5e567379</value>
                    </variable>
                  </response>
                </step>
                <step id="28944021">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175678</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072193">
        <userid>3555</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103491</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177449</timestart>
        <timefinish>1556177458</timefinish>
        <timemodified>1556177458</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103491">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058681">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177460</timemodified>
              <steps>
                <step id="28944811">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177449</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134619</value>
                    </variable>
                  </response>
                </step>
                <step id="28944814">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177456</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bca8f67460f97f8f3675be0591aa8e4a</value>
                    </variable>
                  </response>
                </step>
                <step id="28944817">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177458</timecreated>
                  <userid>3555</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071709">
        <userid>3561</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103007</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171650</timestart>
        <timefinish>1556172659</timefinish>
        <timemodified>1556172659</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103007">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058002">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exersise1a.jar</responsesummary>
              <timemodified>1556172659</timemodified>
              <steps>
                <step id="28943115">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171650</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134244</value>
                    </variable>
                  </response>
                </step>
                <step id="28943189">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172656</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0fe3290045bd1420448ce17300e5238c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943190">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172659</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071747">
        <userid>3561</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103045</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172756</timestart>
        <timefinish>1556173090</timefinish>
        <timemodified>1556173090</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103045">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058040">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173092</timemodified>
              <steps>
                <step id="28943214">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172756</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134281</value>
                    </variable>
                  </response>
                </step>
                <step id="28943268">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173087</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>63aa2f2b90c0d00e57334bd066424881</value>
                    </variable>
                  </response>
                </step>
                <step id="28943269">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173090</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071765">
        <userid>3561</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103063</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173102</timestart>
        <timefinish>1556173527</timefinish>
        <timemodified>1556173527</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103063">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058058">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173529</timemodified>
              <steps>
                <step id="28943273">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173102</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134297</value>
                    </variable>
                  </response>
                </step>
                <step id="28943363">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173523</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2cfa412379a61faad6ed35e3abb91545</value>
                    </variable>
                  </response>
                </step>
                <step id="28943365">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173527</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071817">
        <userid>3561</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103115</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173582</timestart>
        <timefinish>1556174700</timefinish>
        <timemodified>1556174700</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103115">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058110">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174702</timemodified>
              <steps>
                <step id="28943373">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173582</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134344</value>
                    </variable>
                  </response>
                </step>
                <step id="28943772">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174698</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a68bc65fc73bcd66473d29d55b32ae98</value>
                    </variable>
                  </response>
                </step>
                <step id="28943773">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174700</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1083947">
        <userid>3561</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1115266</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>inprogress</state>
        <timestart>1557970986</timestart>
        <timefinish>0</timefinish>
        <timemodified>1557970986</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>$@NULL@$</sumgrades>
        <question_usage id="1115266">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9175150">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>$@NULL@$</responsesummary>
              <timemodified>1557970986</timemodified>
              <steps>
                <step id="29319684">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1557970986</timecreated>
                  <userid>3561</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>136715</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071697">
        <userid>3562</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102995</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171640</timestart>
        <timefinish>1556172450</timefinish>
        <timemodified>1556172450</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1102995">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057990">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172452</timemodified>
              <steps>
                <step id="28943103">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171640</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134232</value>
                    </variable>
                  </response>
                </step>
                <step id="28943159">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172447</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e29782cc56252ad9a086f5bfef7eb1c7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943162">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172450</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071731">
        <userid>3562</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103029</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172463</timestart>
        <timefinish>1556172713</timefinish>
        <timemodified>1556172713</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103029">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058024">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172715</timemodified>
              <steps>
                <step id="28943164">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172463</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134265</value>
                    </variable>
                  </response>
                </step>
                <step id="28943197">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172711</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>07fceb5fcee10ad7372c209d2e345ecb</value>
                    </variable>
                  </response>
                </step>
                <step id="28943199">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172713</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071743">
        <userid>3562</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103041</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172724</timestart>
        <timefinish>1556173103</timefinish>
        <timemodified>1556173103</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103041">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058036">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173105</timemodified>
              <steps>
                <step id="28943202">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172724</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134277</value>
                    </variable>
                  </response>
                </step>
                <step id="28943272">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173101</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2eb4b6bd9645d8c1c449ab6c55147d91</value>
                    </variable>
                  </response>
                </step>
                <step id="28943274">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173103</timecreated>
                  <userid>3562</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071791">
        <userid>3563</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103089</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173283</timestart>
        <timefinish>1556175418</timefinish>
        <timemodified>1556175418</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103089">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058084">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175420</timemodified>
              <steps>
                <step id="28943316">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173283</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134321</value>
                    </variable>
                  </response>
                </step>
                <step id="28943967">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175412</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7099e19db5b29c9312ea5a454fb341c9</value>
                    </variable>
                  </response>
                </step>
                <step id="28943972">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175418</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072027">
        <userid>3563</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103325</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176060</timestart>
        <timefinish>1556176078</timefinish>
        <timemodified>1556176078</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103325">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058436">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176080</timemodified>
              <steps>
                <step id="28944155">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176060</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134516</value>
                    </variable>
                  </response>
                </step>
                <step id="28944164">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176075</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8ba8507eeffd07e8544af529c4ca2d2d</value>
                    </variable>
                  </response>
                </step>
                <step id="28944167">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176078</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072043">
        <userid>3563</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103341</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176171</timestart>
        <timefinish>1556176263</timefinish>
        <timemodified>1556176263</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103341">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058454">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176265</timemodified>
              <steps>
                <step id="28944206">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176171</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134527</value>
                    </variable>
                  </response>
                </step>
                <step id="28944239">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176260</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bbcd9fd7c85c638f0d683e443d9cd835</value>
                    </variable>
                  </response>
                </step>
                <step id="28944243">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556176263</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072056">
        <userid>3563</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103354</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176277</timestart>
        <timefinish>1556177529</timefinish>
        <timemodified>1556177529</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103354">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058469">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177531</timemodified>
              <steps>
                <step id="28944248">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176277</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134535</value>
                    </variable>
                  </response>
                </step>
                <step id="28944858">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177526</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>61d639ade85fbf7fd63063075dff0435</value>
                    </variable>
                  </response>
                </step>
                <step id="28944862">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177529</timecreated>
                  <userid>3563</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071699">
        <userid>3567</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102997</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171643</timestart>
        <timefinish>1556172366</timefinish>
        <timemodified>1556172366</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102997">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057992">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556172366</timemodified>
              <steps>
                <step id="28943105">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171643</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134234</value>
                    </variable>
                  </response>
                </step>
                <step id="28943147">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172363</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>eb46f702e24d68284e1ac8c31924c48f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943148">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172366</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071727">
        <userid>3567</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103025</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172377</timestart>
        <timefinish>1556172586</timefinish>
        <timemodified>1556172586</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103025">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058020">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556172586</timemodified>
              <steps>
                <step id="28943153">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172377</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134261</value>
                    </variable>
                  </response>
                </step>
                <step id="28943176">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172584</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f2d1473b795eab63be9d11fe804b8049</value>
                    </variable>
                  </response>
                </step>
                <step id="28943178">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172586</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071735">
        <userid>3567</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103033</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172594</timestart>
        <timefinish>1556172623</timefinish>
        <timemodified>1556172623</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103033">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058028">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556172625</timemodified>
              <steps>
                <step id="28943179">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172594</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134269</value>
                    </variable>
                  </response>
                </step>
                <step id="28943183">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172621</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>be68f73b1ca399abe5ff07e4eb6874a7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943185">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172623</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071738">
        <userid>3567</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103036</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172631</timestart>
        <timefinish>1556176166</timefinish>
        <timemodified>1556176166</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103036">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058031">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556176168</timemodified>
              <steps>
                <step id="28943187">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172631</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134272</value>
                    </variable>
                  </response>
                </step>
                <step id="28944201">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176163</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5d6fdf8f453fde8be124e2cff8b5d4d4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944205">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176166</timecreated>
                  <userid>3567</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071716">
        <userid>3569</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103014</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171674</timestart>
        <timefinish>1556172727</timefinish>
        <timemodified>1556172727</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103014">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058009">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172729</timemodified>
              <steps>
                <step id="28943122">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171674</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134251</value>
                    </variable>
                  </response>
                </step>
                <step id="28943203">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172724</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>eab91541a45c5839615544da6d60b307</value>
                    </variable>
                  </response>
                </step>
                <step id="28943205">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172727</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071745">
        <userid>3569</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103043</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172736</timestart>
        <timefinish>1556173271</timefinish>
        <timemodified>1556173271</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103043">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058038">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173274</timemodified>
              <steps>
                <step id="28943208">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172736</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134279</value>
                    </variable>
                  </response>
                </step>
                <step id="28943308">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173269</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a39a4eb8e53ba9388cdf8b8eda0c7ae5</value>
                    </variable>
                  </response>
                </step>
                <step id="28943310">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173271</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071789">
        <userid>3569</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103087</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173280</timestart>
        <timefinish>1556174714</timefinish>
        <timemodified>1556174714</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103087">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058082">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174717</timemodified>
              <steps>
                <step id="28943314">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173280</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134319</value>
                    </variable>
                  </response>
                </step>
                <step id="28943774">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174712</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7a09a0a697f7cd33b100afb58242c098</value>
                    </variable>
                  </response>
                </step>
                <step id="28943776">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174714</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071916">
        <userid>3569</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103214</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174729</timestart>
        <timefinish>1556175178</timefinish>
        <timemodified>1556175178</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103214">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058301">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175180</timemodified>
              <steps>
                <step id="28943778">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174729</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134428</value>
                    </variable>
                  </response>
                </step>
                <step id="28943918">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175176</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>693f2da33ae43ecfcab2479cce7639b8</value>
                    </variable>
                  </response>
                </step>
                <step id="28943921">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175178</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071962">
        <userid>3569</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103260</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175252</timestart>
        <timefinish>1556176015</timefinish>
        <timemodified>1556176015</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103260">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058352">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176017</timemodified>
              <steps>
                <step id="28943931">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175252</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134464</value>
                    </variable>
                  </response>
                </step>
                <step id="28944134">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176013</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b187538863e8c943501a87881e437e7f</value>
                    </variable>
                  </response>
                </step>
                <step id="28944136">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176015</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072068">
        <userid>3569</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103366</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176383</timestart>
        <timefinish>1556176430</timefinish>
        <timemodified>1556176430</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103366">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058485">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176432</timemodified>
              <steps>
                <step id="28944289">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176383</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134543</value>
                    </variable>
                  </response>
                </step>
                <step id="28944313">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176428</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>9c58203a9b28efd3f549d453207d91f8</value>
                    </variable>
                  </response>
                </step>
                <step id="28944314">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176430</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072143">
        <userid>3569</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103441</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177120</timestart>
        <timefinish>1556177131</timefinish>
        <timemodified>1556177131</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103441">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058605">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177133</timemodified>
              <steps>
                <step id="28944612">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177120</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134588</value>
                    </variable>
                  </response>
                </step>
                <step id="28944614">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177129</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a6ce00d159c4bef9a241446e32bb09c8</value>
                    </variable>
                  </response>
                </step>
                <step id="28944631">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177131</timecreated>
                  <userid>3569</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072023">
        <userid>3570</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103321</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176031</timestart>
        <timefinish>1556176604</timefinish>
        <timemodified>1556176604</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103321">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058432">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176606</timemodified>
              <steps>
                <step id="28944145">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176031</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134512</value>
                    </variable>
                  </response>
                </step>
                <step id="28944371">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176601</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ef15e13cd20e82859badb7e2ab117693</value>
                    </variable>
                  </response>
                </step>
                <step id="28944372">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176604</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072096">
        <userid>3570</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103394</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176691</timestart>
        <timefinish>1556176702</timefinish>
        <timemodified>1556176702</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103394">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058520">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176704</timemodified>
              <steps>
                <step id="28944395">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176691</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134559</value>
                    </variable>
                  </response>
                </step>
                <step id="28944396">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176700</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f496d478fe97fa5dfeaf5da66213be6f</value>
                    </variable>
                  </response>
                </step>
                <step id="28944397">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176702</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072097">
        <userid>3570</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103395</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176711</timestart>
        <timefinish>1556177281</timefinish>
        <timemodified>1556177281</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103395">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058521">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177283</timemodified>
              <steps>
                <step id="28944398">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176711</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134560</value>
                    </variable>
                  </response>
                </step>
                <step id="28944715">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177278</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>660c8590996c7e8f064ab89011960753</value>
                    </variable>
                  </response>
                </step>
                <step id="28944722">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556177281</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072170">
        <userid>3570</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103468</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177293</timestart>
        <timefinish>1556177764</timefinish>
        <timemodified>1556177764</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103468">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058658">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177766</timemodified>
              <steps>
                <step id="28944725">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177293</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134602</value>
                    </variable>
                  </response>
                </step>
                <step id="28944951">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177760</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c5846a74e9374e634235cf206464f45c</value>
                    </variable>
                  </response>
                </step>
                <step id="28944953">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177764</timecreated>
                  <userid>3570</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071698">
        <userid>3572</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102996</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171642</timestart>
        <timefinish>1556172741</timefinish>
        <timemodified>1556172741</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1102996">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057991">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172743</timemodified>
              <steps>
                <step id="28943104">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171642</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134233</value>
                    </variable>
                  </response>
                </step>
                <step id="28943209">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172738</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1ee3a94f4deef9e0b934810b456be0f0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943211">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172741</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071746">
        <userid>3572</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103044</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172755</timestart>
        <timefinish>1556173312</timefinish>
        <timemodified>1556173312</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103044">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058039">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173314</timemodified>
              <steps>
                <step id="28943213">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172755</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134280</value>
                    </variable>
                  </response>
                </step>
                <step id="28943323">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173309</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e33e0079382242fda6e91ca4ee746510</value>
                    </variable>
                  </response>
                </step>
                <step id="28943325">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173312</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071800">
        <userid>3572</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103098</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173324</timestart>
        <timefinish>1556175422</timefinish>
        <timemodified>1556175422</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103098">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058093">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175424</timemodified>
              <steps>
                <step id="28943328">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173324</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134330</value>
                    </variable>
                  </response>
                </step>
                <step id="28943970">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175420</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>09043256d532126787cc3a27fd2c7806</value>
                    </variable>
                  </response>
                </step>
                <step id="28943973">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175422</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071976">
        <userid>3572</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103274</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175466</timestart>
        <timefinish>1556176004</timefinish>
        <timemodified>1556176004</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103274">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058366">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176006</timemodified>
              <steps>
                <step id="28943982">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175466</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134478</value>
                    </variable>
                  </response>
                </step>
                <step id="28944132">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176001</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a4f2226a31dc32f2442c3a30b42deac7</value>
                    </variable>
                  </response>
                </step>
                <step id="28944133">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176004</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072031">
        <userid>3572</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103329</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176097</timestart>
        <timefinish>1556176106</timefinish>
        <timemodified>1556176106</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103329">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058441">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176108</timemodified>
              <steps>
                <step id="28944174">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176097</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134519</value>
                    </variable>
                  </response>
                </step>
                <step id="28944177">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176103</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>07f6ba811c8e36350731d2c566cfeaa6</value>
                    </variable>
                  </response>
                </step>
                <step id="28944179">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176106</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072113">
        <userid>3572</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103411</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176814</timestart>
        <timefinish>1556176835</timefinish>
        <timemodified>1556176835</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103411">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058558">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176837</timemodified>
              <steps>
                <step id="28944467">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176814</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134571</value>
                    </variable>
                  </response>
                </step>
                <step id="28944474">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176832</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b3cef6d9f65db08efdc1aa7aead584ce</value>
                    </variable>
                  </response>
                </step>
                <step id="28944476">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176835</timecreated>
                  <userid>3572</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071702">
        <userid>3582</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103000</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171644</timestart>
        <timefinish>1556173345</timefinish>
        <timemodified>1556173345</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103000">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057995">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556173345</timemodified>
              <steps>
                <step id="28943108">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171644</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134237</value>
                    </variable>
                  </response>
                </step>
                <step id="28943334">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173342</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2a60d1f8f4dc5daa174365079bdfd282</value>
                    </variable>
                  </response>
                </step>
                <step id="28943335">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173345</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071810">
        <userid>3582</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103108</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173467</timestart>
        <timefinish>1556173473</timefinish>
        <timemodified>1556173473</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103108">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058103">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556173473</timemodified>
              <steps>
                <step id="28943350">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173467</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134338</value>
                    </variable>
                  </response>
                </step>
                <step id="28943351">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173471</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2a60d1f8f4dc5daa174365079bdfd282</value>
                    </variable>
                  </response>
                </step>
                <step id="28943352">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173473</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071816">
        <userid>3582</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103114</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173567</timestart>
        <timefinish>1556173573</timefinish>
        <timemodified>1556173573</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103114">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058109">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>execrise1.jar</responsesummary>
              <timemodified>1556173575</timemodified>
              <steps>
                <step id="28943369">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173567</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134343</value>
                    </variable>
                  </response>
                </step>
                <step id="28943370">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173571</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1830d83c00c92f1123459bdeb47054a2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943371">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173573</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071868">
        <userid>3582</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103166</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174209</timestart>
        <timefinish>1556174217</timefinish>
        <timemodified>1556174217</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103166">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058253">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>execrise1.jar</responsesummary>
              <timemodified>1556174219</timemodified>
              <steps>
                <step id="28943618">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174209</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134389</value>
                    </variable>
                  </response>
                </step>
                <step id="28943621">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174215</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>dfb4aee9313b7a9a94763862bab706b0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943623">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174217</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071972">
        <userid>3582</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103270</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175408</timestart>
        <timefinish>1556175418</timefinish>
        <timemodified>1556175418</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103270">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058362">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>execrise1.jar</responsesummary>
              <timemodified>1556175420</timemodified>
              <steps>
                <step id="28943965">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175408</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134474</value>
                    </variable>
                  </response>
                </step>
                <step id="28943969">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175415</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>babbcabc51d62947cb5498cbbfb7049c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943971">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175418</timecreated>
                  <userid>3582</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071792">
        <userid>3584</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103090</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173283</timestart>
        <timefinish>1556173891</timefinish>
        <timemodified>1556173891</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103090">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058085">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556173891</timemodified>
              <steps>
                <step id="28943317">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173283</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134322</value>
                    </variable>
                  </response>
                </step>
                <step id="28943432">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173888</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>62719fa7394144653708d1e3a656d72c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943433">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173891</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071838">
        <userid>3584</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103136</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173899</timestart>
        <timefinish>1556173979</timefinish>
        <timemodified>1556173979</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103136">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058131">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556173981</timemodified>
              <steps>
                <step id="28943437">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173899</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134364</value>
                    </variable>
                  </response>
                </step>
                <step id="28943456">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173977</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ed151cd84a20dd96e51b5357575381a7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943458">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173979</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071845">
        <userid>3584</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103143</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173989</timestart>
        <timefinish>1556174372</timefinish>
        <timemodified>1556174372</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103143">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058138">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174374</timemodified>
              <steps>
                <step id="28943461">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173989</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134370</value>
                    </variable>
                  </response>
                </step>
                <step id="28943668">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174370</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4f7ebbd3849c9b6d2167fa74949b8d18</value>
                    </variable>
                  </response>
                </step>
                <step id="28943674">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174372</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071898">
        <userid>3584</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103196</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174506</timestart>
        <timefinish>1556174512</timefinish>
        <timemodified>1556174512</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103196">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058283">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174514</timemodified>
              <steps>
                <step id="28943705">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174506</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134411</value>
                    </variable>
                  </response>
                </step>
                <step id="28943707">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174510</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bed7bf10d8bf9097ed4b8f250b8c2fe4</value>
                    </variable>
                  </response>
                </step>
                <step id="28943710">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174512</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071900">
        <userid>3584</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103198</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174536</timestart>
        <timefinish>1556174881</timefinish>
        <timemodified>1556174881</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103198">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058285">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174883</timemodified>
              <steps>
                <step id="28943715">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174536</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134413</value>
                    </variable>
                  </response>
                </step>
                <step id="28943817">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174879</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>83932b4e409a79ca1a84b4c032b744ac</value>
                    </variable>
                  </response>
                </step>
                <step id="28943818">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174881</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072218">
        <userid>3584</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103516</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177595</timestart>
        <timefinish>1556178002</timefinish>
        <timemodified>1556178002</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103516">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058714">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556178004</timemodified>
              <steps>
                <step id="28944906">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177595</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134630</value>
                    </variable>
                  </response>
                </step>
                <step id="28945038">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177999</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0821d956636a96c59f0a6551f42d10fe</value>
                    </variable>
                  </response>
                </step>
                <step id="28945041">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556178002</timecreated>
                  <userid>3584</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071706">
        <userid>3588</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103004</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171648</timestart>
        <timefinish>1556173236</timefinish>
        <timemodified>1556173236</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103004">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057999">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173238</timemodified>
              <steps>
                <step id="28943112">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171648</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134241</value>
                    </variable>
                  </response>
                </step>
                <step id="28943291">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173229</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>aa58b6befb8e1831803e975bc9a83553</value>
                    </variable>
                  </response>
                </step>
                <step id="28943297">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173236</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071821">
        <userid>3588</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103119</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173632</timestart>
        <timefinish>1556173651</timefinish>
        <timemodified>1556173651</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103119">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058114">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173653</timemodified>
              <steps>
                <step id="28943384">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173632</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134348</value>
                    </variable>
                  </response>
                </step>
                <step id="28943390">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173648</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ab539ff51ccfea433ae6db6d545709e2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943391">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556173651</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071861">
        <userid>3588</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103159</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174102</timestart>
        <timefinish>1556174179</timefinish>
        <timemodified>1556174179</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103159">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058245">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174181</timemodified>
              <steps>
                <step id="28943593">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174102</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134383</value>
                    </variable>
                  </response>
                </step>
                <step id="28943607">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174176</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>989b52b12b59ff76fd97b514e494a5f6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943612">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174179</timecreated>
                  <userid>3588</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071777">
        <userid>3601</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103075</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173238</timestart>
        <timefinish>1556174645</timefinish>
        <timemodified>1556174645</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103075">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058070">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174647</timemodified>
              <steps>
                <step id="28943298">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173238</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134308</value>
                    </variable>
                  </response>
                </step>
                <step id="28943751">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174641</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>80b17c5e324d8fc51ea630704b9e3035</value>
                    </variable>
                  </response>
                </step>
                <step id="28943757">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174645</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071945">
        <userid>3601</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103243</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175040</timestart>
        <timefinish>1556175292</timefinish>
        <timemodified>1556175292</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103243">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058334">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175295</timemodified>
              <steps>
                <step id="28943870">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175040</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134450</value>
                    </variable>
                  </response>
                </step>
                <step id="28943872">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175047</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2b9ec39012ed7fb26fafdc23193f9b7f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943940">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175290</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7fcf1e7ab456c160a2ec7e674a27632f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943941">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175292</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071986">
        <userid>3601</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103284</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175660</timestart>
        <timefinish>1556175671</timefinish>
        <timemodified>1556175671</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103284">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058376">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175673</timemodified>
              <steps>
                <step id="28944006">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175660</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134485</value>
                    </variable>
                  </response>
                </step>
                <step id="28944008">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175669</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>98edf69f9bd0baf37ed206293b70252b</value>
                    </variable>
                  </response>
                </step>
                <step id="28944012">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175671</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071994">
        <userid>3601</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103292</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175810</timestart>
        <timefinish>1556175985</timefinish>
        <timemodified>1556175985</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103292">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058384">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175987</timemodified>
              <steps>
                <step id="28944038">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175810</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134492</value>
                    </variable>
                  </response>
                </step>
                <step id="28944118">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175983</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f527640d9ae3646a7dcc5b82684abb9c</value>
                    </variable>
                  </response>
                </step>
                <step id="28944120">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175985</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072129">
        <userid>3601</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103427</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177007</timestart>
        <timefinish>1556177014</timefinish>
        <timemodified>1556177014</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103427">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058578">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556177016</timemodified>
              <steps>
                <step id="28944538">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177007</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134580</value>
                    </variable>
                  </response>
                </step>
                <step id="28944541">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177013</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>900cd2c6ea63deb2dc740bb26aff8d24</value>
                    </variable>
                  </response>
                </step>
                <step id="28944543">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177014</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072153">
        <userid>3601</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103451</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177175</timestart>
        <timefinish>1556177184</timefinish>
        <timemodified>1556177184</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103451">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058638">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177186</timemodified>
              <steps>
                <step id="28944656">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177175</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134592</value>
                    </variable>
                  </response>
                </step>
                <step id="28944659">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177182</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>47f0b637ae9a141a3c79d0a837630ce4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944661">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177184</timecreated>
                  <userid>3601</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071831">
        <userid>3605</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103129</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173755</timestart>
        <timefinish>1556174586</timefinish>
        <timemodified>1556174586</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103129">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058124">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174588</timemodified>
              <steps>
                <step id="28943414">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173755</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134358</value>
                    </variable>
                  </response>
                </step>
                <step id="28943729">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174579</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2346cf3325613960ba975e0cd475e28e</value>
                    </variable>
                  </response>
                </step>
                <step id="28943732">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174586</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071909">
        <userid>3605</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103207</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174632</timestart>
        <timefinish>1556175398</timefinish>
        <timemodified>1556175398</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103207">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058294">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175400</timemodified>
              <steps>
                <step id="28943747">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174632</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134422</value>
                    </variable>
                  </response>
                </step>
                <step id="28943961">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175395</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6d179a43f395d49caa1a8caacd7652ad</value>
                    </variable>
                  </response>
                </step>
                <step id="28943963">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175398</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071973">
        <userid>3605</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103271</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175413</timestart>
        <timefinish>1556175870</timefinish>
        <timemodified>1556175870</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103271">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058363">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175872</timemodified>
              <steps>
                <step id="28943968">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175413</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134475</value>
                    </variable>
                  </response>
                </step>
                <step id="28944058">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175867</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>843c0b26ed27da56505186d9f71b3962</value>
                    </variable>
                  </response>
                </step>
                <step id="28944060">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175870</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072011">
        <userid>3605</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103309</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175949</timestart>
        <timefinish>1556176811</timefinish>
        <timemodified>1556176811</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103309">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058414">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176813</timemodified>
              <steps>
                <step id="28944105">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175949</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134506</value>
                    </variable>
                  </response>
                </step>
                <step id="28944463">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176808</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5f6163737e0cb9d6656a8d4f18b3098d</value>
                    </variable>
                  </response>
                </step>
                <step id="28944466">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176811</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072166">
        <userid>3605</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103464</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177261</timestart>
        <timefinish>1556177277</timefinish>
        <timemodified>1556177277</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103464">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058653">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177279</timemodified>
              <steps>
                <step id="28944703">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177261</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134599</value>
                    </variable>
                  </response>
                </step>
                <step id="28944713">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177274</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>465c030df9f80531bbe93c6ae6d14c3f</value>
                    </variable>
                  </response>
                </step>
                <step id="28944718">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177277</timecreated>
                  <userid>3605</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071700">
        <userid>3610</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102998</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171643</timestart>
        <timefinish>1556172566</timefinish>
        <timemodified>1556172566</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102998">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057993">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exsercise1a.jar</responsesummary>
              <timemodified>1556172568</timemodified>
              <steps>
                <step id="28943106">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171643</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134235</value>
                    </variable>
                  </response>
                </step>
                <step id="28943171">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172562</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4c5d80bd697661a6f82aa104dbfa075f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943173">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172566</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071734">
        <userid>3610</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103032</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172579</timestart>
        <timefinish>1556172719</timefinish>
        <timemodified>1556172719</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103032">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058027">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exsercise1a.jar</responsesummary>
              <timemodified>1556172721</timemodified>
              <steps>
                <step id="28943174">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172579</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134268</value>
                    </variable>
                  </response>
                </step>
                <step id="28943200">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172717</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>22621f4f5d7e438b4ed28f69975ed72c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943201">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172719</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071744">
        <userid>3610</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103042</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172730</timestart>
        <timefinish>1556175593</timefinish>
        <timemodified>1556175593</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103042">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058037">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exsercise1a.jar</responsesummary>
              <timemodified>1556175595</timemodified>
              <steps>
                <step id="28943206">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172730</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134278</value>
                    </variable>
                  </response>
                </step>
                <step id="28943996">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175591</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a9666c293c234d03991ab5b91c4b2db0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943998">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175593</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072069">
        <userid>3610</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103367</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176390</timestart>
        <timefinish>1556176472</timefinish>
        <timemodified>1556176472</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103367">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058486">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exsercise1a.jar</responsesummary>
              <timemodified>1556176474</timemodified>
              <steps>
                <step id="28944292">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176390</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134544</value>
                    </variable>
                  </response>
                </step>
                <step id="28944328">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176470</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b204d733fb49f97414ac7268662301e7</value>
                    </variable>
                  </response>
                </step>
                <step id="28944334">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176472</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072094">
        <userid>3610</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103392</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176650</timestart>
        <timefinish>1556176658</timefinish>
        <timemodified>1556176658</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103392">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058518">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exsercise1a.jar</responsesummary>
              <timemodified>1556176661</timemodified>
              <steps>
                <step id="28944386">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176650</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134557</value>
                    </variable>
                  </response>
                </step>
                <step id="28944389">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176656</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e02c0a9b1fc84635a27b46c1fed446de</value>
                    </variable>
                  </response>
                </step>
                <step id="28944392">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176658</timecreated>
                  <userid>3610</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071779">
        <userid>3613</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103077</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173243</timestart>
        <timefinish>1556174553</timefinish>
        <timemodified>1556174553</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103077">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058072">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>ftoc.jar</responsesummary>
              <timemodified>1556174555</timemodified>
              <steps>
                <step id="28943300">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173243</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134310</value>
                    </variable>
                  </response>
                </step>
                <step id="28943718">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174546</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f632379db10d9afea707585d0a2636d5</value>
                    </variable>
                  </response>
                </step>
                <step id="28943721">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174553</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071910">
        <userid>3613</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103208</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174633</timestart>
        <timefinish>1556174647</timefinish>
        <timemodified>1556174647</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103208">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058295">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556174649</timemodified>
              <steps>
                <step id="28943748">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174633</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134423</value>
                    </variable>
                  </response>
                </step>
                <step id="28943749">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174638</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bc6a03baaf7650dd6befbf78be8cda4c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943758">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174647</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071921">
        <userid>3613</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103219</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174762</timestart>
        <timefinish>1556174769</timefinish>
        <timemodified>1556174769</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103219">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058306">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174771</timemodified>
              <steps>
                <step id="28943792">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174762</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134432</value>
                    </variable>
                  </response>
                </step>
                <step id="28943793">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174767</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>96b141da9ee2484b6d6ad8684ab2ffb4</value>
                    </variable>
                  </response>
                </step>
                <step id="28943794">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174769</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071927">
        <userid>3613</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103225</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174824</timestart>
        <timefinish>1556176028</timefinish>
        <timemodified>1556176028</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103225">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058312">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176030</timemodified>
              <steps>
                <step id="28943802">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174824</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134437</value>
                    </variable>
                  </response>
                </step>
                <step id="28944140">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176025</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d8e6aaa634136f9b6657ec01f5118559</value>
                    </variable>
                  </response>
                </step>
                <step id="28944144">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176028</timecreated>
                  <userid>3613</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071720">
        <userid>3620</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103018</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171841</timestart>
        <timefinish>1556173678</timefinish>
        <timemodified>1556173678</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103018">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058013">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.java</responsesummary>
              <timemodified>1556173678</timemodified>
              <steps>
                <step id="28943128">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171841</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134254</value>
                    </variable>
                  </response>
                </step>
                <step id="28943394">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173673</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>173285e6a10820acf69141b926e81e50</value>
                    </variable>
                  </response>
                </step>
                <step id="28943395">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173678</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071842">
        <userid>3620</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103140</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173968</timestart>
        <timefinish>1556173983</timefinish>
        <timemodified>1556173983</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103140">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058135">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173985</timemodified>
              <steps>
                <step id="28943451">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173968</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134368</value>
                    </variable>
                  </response>
                </step>
                <step id="28943457">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173981</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e43e86f87366822d3cc28791a7c9e0a8</value>
                    </variable>
                  </response>
                </step>
                <step id="28943459">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173983</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071882">
        <userid>3620</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103180</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174356</timestart>
        <timefinish>1556174368</timefinish>
        <timemodified>1556174368</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103180">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058267">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174370</timemodified>
              <steps>
                <step id="28943664">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174356</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134398</value>
                    </variable>
                  </response>
                </step>
                <step id="28943665">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174365</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c8e53f466198d0147de800d358db750e</value>
                    </variable>
                  </response>
                </step>
                <step id="28943669">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174368</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072051">
        <userid>3620</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103349</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176244</timestart>
        <timefinish>1556176254</timefinish>
        <timemodified>1556176254</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103349">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058463">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176256</timemodified>
              <steps>
                <step id="28944232">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176244</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134532</value>
                    </variable>
                  </response>
                </step>
                <step id="28944235">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176252</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7acf731836aed1fefa22d20b446a3332</value>
                    </variable>
                  </response>
                </step>
                <step id="28944236">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176254</timecreated>
                  <userid>3620</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071704">
        <userid>3629</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103002</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171646</timestart>
        <timefinish>1556173903</timefinish>
        <timemodified>1556173903</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103002">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057997">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173905</timemodified>
              <steps>
                <step id="28943110">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171646</timecreated>
                  <userid>3629</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134239</value>
                    </variable>
                  </response>
                </step>
                <step id="28943438">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173900</timecreated>
                  <userid>3629</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8b7253c8a0a8b513f95e1902f3224d5f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943439">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173903</timecreated>
                  <userid>3629</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071965">
        <userid>3629</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103263</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>inprogress</state>
        <timestart>1556175284</timestart>
        <timefinish>0</timefinish>
        <timemodified>1556175284</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>$@NULL@$</sumgrades>
        <question_usage id="1103263">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058355">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>$@NULL@$</responsesummary>
              <timemodified>1556175284</timemodified>
              <steps>
                <step id="28943939">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175284</timecreated>
                  <userid>3629</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134467</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071773">
        <userid>3633</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103071</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173228</timestart>
        <timefinish>1556175019</timefinish>
        <timemodified>1556175019</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103071">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058066">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175021</timemodified>
              <steps>
                <step id="28943290">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173228</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134304</value>
                    </variable>
                  </response>
                </step>
                <step id="28943851">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175005</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>db58081fad2a757a3732b6dc45590364</value>
                    </variable>
                  </response>
                </step>
                <step id="28943862">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175019</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072017">
        <userid>3633</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103315</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175981</timestart>
        <timefinish>1556176047</timefinish>
        <timemodified>1556176047</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103315">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058422">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176049</timemodified>
              <steps>
                <step id="28944117">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175981</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134509</value>
                    </variable>
                  </response>
                </step>
                <step id="28944147">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176045</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>db58081fad2a757a3732b6dc45590364</value>
                    </variable>
                  </response>
                </step>
                <step id="28944150">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176047</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072034">
        <userid>3633</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103332</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176104</timestart>
        <timefinish>1556176112</timefinish>
        <timemodified>1556176112</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103332">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058444">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176114</timemodified>
              <steps>
                <step id="28944178">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176104</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134521</value>
                    </variable>
                  </response>
                </step>
                <step id="28944181">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176110</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8de4a16ed7419a6083ce0b71e7b94807</value>
                    </variable>
                  </response>
                </step>
                <step id="28944182">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176112</timecreated>
                  <userid>3633</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071776">
        <userid>3639</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103074</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173237</timestart>
        <timefinish>1556174133</timefinish>
        <timemodified>1556174133</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103074">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058069">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174135</timemodified>
              <steps>
                <step id="28943296">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173237</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134307</value>
                    </variable>
                  </response>
                </step>
                <step id="28943596">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174130</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8c333006aca87ed8274a4c6f9bf4115f</value>
                    </variable>
                  </response>
                </step>
                <step id="28943597">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174133</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071895">
        <userid>3639</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103193</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174497</timestart>
        <timefinish>1556174518</timefinish>
        <timemodified>1556174518</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103193">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058280">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174521</timemodified>
              <steps>
                <step id="28943701">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174497</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134408</value>
                    </variable>
                  </response>
                </step>
                <step id="28943711">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174516</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7965db6604d082d31157b879717ee351</value>
                    </variable>
                  </response>
                </step>
                <step id="28943713">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174518</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071971">
        <userid>3639</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103269</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175383</timestart>
        <timefinish>1556175391</timefinish>
        <timemodified>1556175391</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103269">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058361">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175393</timemodified>
              <steps>
                <step id="28943957">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175383</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134473</value>
                    </variable>
                  </response>
                </step>
                <step id="28943958">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175388</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>17537a9123e5ca5aa08afeadfb6da467</value>
                    </variable>
                  </response>
                </step>
                <step id="28943959">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175391</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072007">
        <userid>3639</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103305</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175906</timestart>
        <timefinish>1556175941</timefinish>
        <timemodified>1556175941</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103305">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058410">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175943</timemodified>
              <steps>
                <step id="28944092">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175906</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134502</value>
                    </variable>
                  </response>
                </step>
                <step id="28944103">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175938</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a26e143bebdbfbcb500ef4f43c4d6ef5</value>
                    </variable>
                  </response>
                </step>
                <step id="28944104">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175941</timecreated>
                  <userid>3639</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071693">
        <userid>3647</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102991</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171607</timestart>
        <timefinish>1556174965</timefinish>
        <timemodified>1556174965</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102991">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057986">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174967</timemodified>
              <steps>
                <step id="28943099">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171607</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134228</value>
                    </variable>
                  </response>
                </step>
                <step id="28943839">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174963</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1e60db27ed80768e831ca1384d63c1fd</value>
                    </variable>
                  </response>
                </step>
                <step id="28943845">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174965</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071939">
        <userid>3647</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103237</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174989</timestart>
        <timefinish>1556175093</timefinish>
        <timemodified>1556175093</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103237">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058327">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175095</timemodified>
              <steps>
                <step id="28943846">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174989</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134446</value>
                    </variable>
                  </response>
                </step>
                <step id="28943884">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175090</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>cedf0f55c0045aa5443bc2f4f142747e</value>
                    </variable>
                  </response>
                </step>
                <step id="28943886">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175093</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071954">
        <userid>3647</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103252</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175120</timestart>
        <timefinish>1556177050</timefinish>
        <timemodified>1556177050</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103252">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058343">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177053</timemodified>
              <steps>
                <step id="28943900">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175120</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134458</value>
                    </variable>
                  </response>
                </step>
                <step id="28944552">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177048</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b98dee77a6b5d8b2f0096a2ea17030b2</value>
                    </variable>
                  </response>
                </step>
                <step id="28944554">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177050</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072151">
        <userid>3647</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103449</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177159</timestart>
        <timefinish>1556177168</timefinish>
        <timemodified>1556177168</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103449">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058636">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177171</timemodified>
              <steps>
                <step id="28944649">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177159</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134590</value>
                    </variable>
                  </response>
                </step>
                <step id="28944651">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177166</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>21277e055268b5c62ec921d201690be2</value>
                    </variable>
                  </response>
                </step>
                <step id="28944655">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177168</timecreated>
                  <userid>3647</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072004">
        <userid>3652</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103302</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175894</timestart>
        <timefinish>1556178195</timefinish>
        <timemodified>1556178195</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103302">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058406">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556178197</timemodified>
              <steps>
                <step id="28944084">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175894</timecreated>
                  <userid>3652</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134500</value>
                    </variable>
                  </response>
                </step>
                <step id="28945105">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178192</timecreated>
                  <userid>3652</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>939720759b6e3626b9c0b14dd65552eb</value>
                    </variable>
                  </response>
                </step>
                <step id="28945107">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556178195</timecreated>
                  <userid>3652</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071787">
        <userid>3653</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103085</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173278</timestart>
        <timefinish>1556174152</timefinish>
        <timemodified>1556174152</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103085">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058080">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174154</timemodified>
              <steps>
                <step id="28943312">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173278</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134317</value>
                    </variable>
                  </response>
                </step>
                <step id="28943600">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174149</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>328f6040c910af235f70f3b0d0aaf38b</value>
                    </variable>
                  </response>
                </step>
                <step id="28943601">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174152</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071865">
        <userid>3653</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103163</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174187</timestart>
        <timefinish>1556176451</timefinish>
        <timemodified>1556176451</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103163">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058250">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176453</timemodified>
              <steps>
                <step id="28943615">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174187</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134386</value>
                    </variable>
                  </response>
                </step>
                <step id="28944325">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176449</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>603993d8e6eefd3342d80e416b9d0db3</value>
                    </variable>
                  </response>
                </step>
                <step id="28944327">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176451</timecreated>
                  <userid>3653</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071710">
        <userid>3655</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103008</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171651</timestart>
        <timefinish>1556172379</timefinish>
        <timemodified>1556172379</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103008">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058003">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556172381</timemodified>
              <steps>
                <step id="28943116">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171651</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134245</value>
                    </variable>
                  </response>
                </step>
                <step id="28943152">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172376</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6d2f81d880afd2a81d9d6678822bccef</value>
                    </variable>
                  </response>
                </step>
                <step id="28943154">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172379</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071728">
        <userid>3655</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103026</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172391</timestart>
        <timefinish>1556172772</timefinish>
        <timemodified>1556172772</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103026">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058021">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556172774</timemodified>
              <steps>
                <step id="28943155">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172391</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134262</value>
                    </variable>
                  </response>
                </step>
                <step id="28943216">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172769</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3393a0d2dedcb84c88ff397d80755217</value>
                    </variable>
                  </response>
                </step>
                <step id="28943219">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556172772</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071749">
        <userid>3655</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103047</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172785</timestart>
        <timefinish>1556174263</timefinish>
        <timemodified>1556174263</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103047">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058042">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174265</timemodified>
              <steps>
                <step id="28943222">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172785</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134283</value>
                    </variable>
                  </response>
                </step>
                <step id="28943630">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174256</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e1e4f9bd1d3960bb13f1bf63307f2155</value>
                    </variable>
                  </response>
                </step>
                <step id="28943634">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174263</timecreated>
                  <userid>3655</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071778">
        <userid>3657</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103076</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173241</timestart>
        <timefinish>1556176064</timefinish>
        <timemodified>1556176064</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103076">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058071">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176066</timemodified>
              <steps>
                <step id="28943299">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173241</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134309</value>
                    </variable>
                  </response>
                </step>
                <step id="28944153">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176052</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6d4958d947e9ca0789d594ac954c0132</value>
                    </variable>
                  </response>
                </step>
                <step id="28944160">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176064</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072046">
        <userid>3657</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103344</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176181</timestart>
        <timefinish>1556176279</timefinish>
        <timemodified>1556176279</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103344">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058457">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176281</timemodified>
              <steps>
                <step id="28944211">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176181</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134530</value>
                    </variable>
                  </response>
                </step>
                <step id="28944247">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176277</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bfaf6909b501bcbd2fd4b5c0ba66eba1</value>
                    </variable>
                  </response>
                </step>
                <step id="28944252">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176279</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072344">
        <userid>3657</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103642</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556179058</timestart>
        <timefinish>1556179073</timefinish>
        <timemodified>1556179073</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103642">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058899">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179074</timemodified>
              <steps>
                <step id="28945518">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179058</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134706</value>
                    </variable>
                  </response>
                </step>
                <step id="28945528">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179069</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28945531">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556179073</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072349">
        <userid>3657</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103647</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556179086</timestart>
        <timefinish>1556179192</timefinish>
        <timemodified>1556179192</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103647">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058904">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179193</timemodified>
              <steps>
                <step id="28945538">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179086</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134711</value>
                    </variable>
                  </response>
                </step>
                <step id="28945561">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179190</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28945563">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556179192</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072430">
        <userid>3657</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103728</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556179887</timestart>
        <timefinish>1556179900</timefinish>
        <timemodified>1556179900</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103728">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059015">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556179901</timemodified>
              <steps>
                <step id="28945858">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179887</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134746</value>
                    </variable>
                  </response>
                </step>
                <step id="28945863">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556179897</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28945864">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556179900</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072448">
        <userid>3657</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103746</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180068</timestart>
        <timefinish>1556180079</timefinish>
        <timemodified>1556180079</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103746">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059043">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180081</timemodified>
              <steps>
                <step id="28945937">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180068</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134752</value>
                    </variable>
                  </response>
                </step>
                <step id="28945940">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180076</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28945943">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556180079</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072477">
        <userid>3657</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103775</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180477</timestart>
        <timefinish>1556180489</timefinish>
        <timemodified>1556180489</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103775">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059086">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180491</timemodified>
              <steps>
                <step id="28946071">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180477</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134760</value>
                    </variable>
                  </response>
                </step>
                <step id="28946074">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180485</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946076">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556180489</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072495">
        <userid>3657</userid>
        <attemptnum>8</attemptnum>
        <uniqueid>1103793</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180601</timestart>
        <timefinish>1556180611</timefinish>
        <timemodified>1556180611</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103793">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059112">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180612</timemodified>
              <steps>
                <step id="28946131">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180601</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134766</value>
                    </variable>
                  </response>
                </step>
                <step id="28946133">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180609</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946136">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556180611</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072509">
        <userid>3657</userid>
        <attemptnum>9</attemptnum>
        <uniqueid>1103807</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180775</timestart>
        <timefinish>1556180786</timefinish>
        <timemodified>1556180786</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103807">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059134">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180787</timemodified>
              <steps>
                <step id="28946219">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180775</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134772</value>
                    </variable>
                  </response>
                </step>
                <step id="28946224">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180783</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946225">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556180786</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072513">
        <userid>3657</userid>
        <attemptnum>10</attemptnum>
        <uniqueid>1103811</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556180822</timestart>
        <timefinish>1556180833</timefinish>
        <timemodified>1556180833</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103811">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059139">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556180834</timemodified>
              <steps>
                <step id="28946237">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180822</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134775</value>
                    </variable>
                  </response>
                </step>
                <step id="28946245">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556180831</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946248">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556180833</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072523">
        <userid>3657</userid>
        <attemptnum>11</attemptnum>
        <uniqueid>1103821</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181012</timestart>
        <timefinish>1556181023</timefinish>
        <timemodified>1556181023</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103821">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059152">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181024</timemodified>
              <steps>
                <step id="28946304">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181012</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134781</value>
                    </variable>
                  </response>
                </step>
                <step id="28946308">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181021</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946309">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556181023</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072536">
        <userid>3657</userid>
        <attemptnum>12</attemptnum>
        <uniqueid>1103834</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181230</timestart>
        <timefinish>1556181240</timefinish>
        <timemodified>1556181240</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103834">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059188">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181241</timemodified>
              <steps>
                <step id="28946372">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181230</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134787</value>
                    </variable>
                  </response>
                </step>
                <step id="28946374">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181238</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946377">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556181240</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072539">
        <userid>3657</userid>
        <attemptnum>13</attemptnum>
        <uniqueid>1103837</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181313</timestart>
        <timefinish>1556181323</timefinish>
        <timemodified>1556181323</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103837">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059191">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181325</timemodified>
              <steps>
                <step id="28946390">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181313</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134790</value>
                    </variable>
                  </response>
                </step>
                <step id="28946392">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181321</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946394">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556181323</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072544">
        <userid>3657</userid>
        <attemptnum>14</attemptnum>
        <uniqueid>1103842</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181392</timestart>
        <timefinish>1556181464</timefinish>
        <timemodified>1556181464</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103842">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059196">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181466</timemodified>
              <steps>
                <step id="28946412">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181392</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134795</value>
                    </variable>
                  </response>
                </step>
                <step id="28946433">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181462</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c2da8707056aa74d7779a28d1e98a8bd</value>
                    </variable>
                  </response>
                </step>
                <step id="28946434">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556181464</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072548">
        <userid>3657</userid>
        <attemptnum>15</attemptnum>
        <uniqueid>1103846</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181507</timestart>
        <timefinish>1556181516</timefinish>
        <timemodified>1556181516</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103846">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059201">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181518</timemodified>
              <steps>
                <step id="28946442">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181507</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134797</value>
                    </variable>
                  </response>
                </step>
                <step id="28946444">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181514</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7e3b54a658f2d342a8415c438f66cfe1</value>
                    </variable>
                  </response>
                </step>
                <step id="28946445">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556181516</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072558">
        <userid>3657</userid>
        <attemptnum>16</attemptnum>
        <uniqueid>1103856</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556181800</timestart>
        <timefinish>1556181856</timefinish>
        <timemodified>1556181856</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103856">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059212">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556181858</timemodified>
              <steps>
                <step id="28946495">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181800</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134801</value>
                    </variable>
                  </response>
                </step>
                <step id="28946503">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556181854</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>13745278b064a2b85beffef951dbf06b</value>
                    </variable>
                  </response>
                </step>
                <step id="28946505">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556181856</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072565">
        <userid>3657</userid>
        <attemptnum>17</attemptnum>
        <uniqueid>1103863</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556182305</timestart>
        <timefinish>1556182313</timefinish>
        <timemodified>1556182313</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103863">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059222">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556182315</timemodified>
              <steps>
                <step id="28946559">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556182305</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134805</value>
                    </variable>
                  </response>
                </step>
                <step id="28946561">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556182311</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0bb0e16749d419130ead5044029a68f3</value>
                    </variable>
                  </response>
                </step>
                <step id="28946563">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556182313</timecreated>
                  <userid>3657</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071804">
        <userid>3661</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103102</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173362</timestart>
        <timefinish>1556174648</timefinish>
        <timemodified>1556174648</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103102">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058097">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174650</timemodified>
              <steps>
                <step id="28943338">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173362</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134334</value>
                    </variable>
                  </response>
                </step>
                <step id="28943754">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174643</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>14dcabcada61e78051bf115feefac144</value>
                    </variable>
                  </response>
                </step>
                <step id="28943760">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174648</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071912">
        <userid>3661</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103210</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174662</timestart>
        <timefinish>1556174751</timefinish>
        <timemodified>1556174751</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103210">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058297">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174753</timemodified>
              <steps>
                <step id="28943763">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174662</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134425</value>
                    </variable>
                  </response>
                </step>
                <step id="28943787">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174749</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0dd959003b7149ec83816220d2517bb2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943788">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174751</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071918">
        <userid>3661</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103216</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174760</timestart>
        <timefinish>1556175335</timefinish>
        <timemodified>1556175335</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103216">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058303">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175337</timemodified>
              <steps>
                <step id="28943789">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174760</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134429</value>
                    </variable>
                  </response>
                </step>
                <step id="28943948">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175333</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>670de2f2d66c57dd167cbdfe017702ac</value>
                    </variable>
                  </response>
                </step>
                <step id="28943949">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175335</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071968">
        <userid>3661</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103266</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175363</timestart>
        <timefinish>1556176508</timefinish>
        <timemodified>1556176508</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103266">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058358">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176510</timemodified>
              <steps>
                <step id="28943952">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175363</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134470</value>
                    </variable>
                  </response>
                </step>
                <step id="28944344">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176504</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>09bcc40b94401e4b77cc8f288f3f5d3f</value>
                    </variable>
                  </response>
                </step>
                <step id="28944347">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176508</timecreated>
                  <userid>3661</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071696">
        <userid>3669</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102994</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171640</timestart>
        <timefinish>1556173033</timefinish>
        <timemodified>1556173033</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102994">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057989">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173035</timemodified>
              <steps>
                <step id="28943102">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171640</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134231</value>
                    </variable>
                  </response>
                </step>
                <step id="28943264">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173030</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ea11ab98b66bcbed2e25aaec409f04f1</value>
                    </variable>
                  </response>
                </step>
                <step id="28943265">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173033</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071781">
        <userid>3669</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103079</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173258</timestart>
        <timefinish>1556173432</timefinish>
        <timemodified>1556173432</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103079">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058074">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173434</timemodified>
              <steps>
                <step id="28943302">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173258</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134312</value>
                    </variable>
                  </response>
                </step>
                <step id="28943346">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173428</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>23762c57885365b313d7b58528f89a13</value>
                    </variable>
                  </response>
                </step>
                <step id="28943347">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556173432</timecreated>
                  <userid>3669</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071799">
        <userid>3671</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103097</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173320</timestart>
        <timefinish>1556174645</timefinish>
        <timemodified>1556174645</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103097">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058092">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174647</timemodified>
              <steps>
                <step id="28943327">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173320</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134329</value>
                    </variable>
                  </response>
                </step>
                <step id="28943752">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174642</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bdfb8f4cbd9861fb7c00c6bea113fe79</value>
                    </variable>
                  </response>
                </step>
                <step id="28943756">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174645</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071967">
        <userid>3671</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103265</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175329</timestart>
        <timefinish>1556175343</timefinish>
        <timemodified>1556175343</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103265">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058357">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175345</timemodified>
              <steps>
                <step id="28943946">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175329</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134469</value>
                    </variable>
                  </response>
                </step>
                <step id="28943950">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175340</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a46cce82c0d37708b9f5a3186c434b27</value>
                    </variable>
                  </response>
                </step>
                <step id="28943951">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175343</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072162">
        <userid>3671</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103460</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177248</timestart>
        <timefinish>1556177276</timefinish>
        <timemodified>1556177276</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103460">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058649">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556177278</timemodified>
              <steps>
                <step id="28944695">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177248</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134597</value>
                    </variable>
                  </response>
                </step>
                <step id="28944712">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177273</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>6cbe081a9b5957a29e9d1f429e6f594d</value>
                    </variable>
                  </response>
                </step>
                <step id="28944716">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177276</timecreated>
                  <userid>3671</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071796">
        <userid>3674</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103094</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173309</timestart>
        <timefinish>1556174181</timefinish>
        <timemodified>1556174181</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103094">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058089">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174182</timemodified>
              <steps>
                <step id="28943322">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173309</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134326</value>
                    </variable>
                  </response>
                </step>
                <step id="28943609">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174178</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>731650a46c87d079014432f13d6f65c8</value>
                    </variable>
                  </response>
                </step>
                <step id="28943613">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174181</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071874">
        <userid>3674</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103172</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174321</timestart>
        <timefinish>1556174331</timefinish>
        <timemodified>1556174331</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103172">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058259">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174333</timemodified>
              <steps>
                <step id="28943649">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174321</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134394</value>
                    </variable>
                  </response>
                </step>
                <step id="28943654">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174328</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2acce14d85cbe4afe30e9f19113a0e73</value>
                    </variable>
                  </response>
                </step>
                <step id="28943657">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174331</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071879">
        <userid>3674</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103177</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174342</timestart>
        <timefinish>1556174840</timefinish>
        <timemodified>1556174840</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103177">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058264">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174842</timemodified>
              <steps>
                <step id="28943660">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174342</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134395</value>
                    </variable>
                  </response>
                </step>
                <step id="28943806">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174837</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>81c652dae7fdfddedd4ac3df8822733b</value>
                    </variable>
                  </response>
                </step>
                <step id="28943809">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174840</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072045">
        <userid>3674</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103343</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176180</timestart>
        <timefinish>1556176192</timefinish>
        <timemodified>1556176192</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103343">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058456">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176194</timemodified>
              <steps>
                <step id="28944210">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176180</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134529</value>
                    </variable>
                  </response>
                </step>
                <step id="28944214">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176189</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>09dcbf60118a3b2c4b8b7e0f567854b4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944217">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176192</timecreated>
                  <userid>3674</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071714">
        <userid>3676</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103012</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171660</timestart>
        <timefinish>1556175409</timefinish>
        <timemodified>1556175409</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103012">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058007">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175412</timemodified>
              <steps>
                <step id="28943120">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171660</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134249</value>
                    </variable>
                  </response>
                </step>
                <step id="28943964">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175407</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>de1a2041457c3a319d40ab32b51d8e9e</value>
                    </variable>
                  </response>
                </step>
                <step id="28943966">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175409</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071981">
        <userid>3676</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103279</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175580</timestart>
        <timefinish>1556175654</timefinish>
        <timemodified>1556175654</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103279">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058371">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175656</timemodified>
              <steps>
                <step id="28943995">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175580</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134481</value>
                    </variable>
                  </response>
                </step>
                <step id="28944003">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175651</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>67d3b415e535d8a4031aba99d5393cc1</value>
                    </variable>
                  </response>
                </step>
                <step id="28944004">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175654</timecreated>
                  <userid>3676</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071806">
        <userid>3678</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103104</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173411</timestart>
        <timefinish>1556175031</timefinish>
        <timemodified>1556175031</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103104">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058099">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175033</timemodified>
              <steps>
                <step id="28943342">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173411</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134335</value>
                    </variable>
                  </response>
                </step>
                <step id="28943865">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175028</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2932fd6b9b43a90cf80544eeca885b1d</value>
                    </variable>
                  </response>
                </step>
                <step id="28943869">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556175031</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071947">
        <userid>3678</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103245</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175056</timestart>
        <timefinish>1556176716</timefinish>
        <timemodified>1556176716</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103245">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058336">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176718</timemodified>
              <steps>
                <step id="28943875">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175056</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134452</value>
                    </variable>
                  </response>
                </step>
                <step id="28944399">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176714</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>90c935138ae635237fd7767034d314b5</value>
                    </variable>
                  </response>
                </step>
                <step id="28944400">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556176716</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072115">
        <userid>3678</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103413</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176835</timestart>
        <timefinish>1556176955</timefinish>
        <timemodified>1556176955</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103413">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058560">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176957</timemodified>
              <steps>
                <step id="28944475">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176835</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134573</value>
                    </variable>
                  </response>
                </step>
                <step id="28944520">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176953</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>5a5f2834469237148ee34453c90d8e54</value>
                    </variable>
                  </response>
                </step>
                <step id="28944522">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176955</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072264">
        <userid>3678</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103562</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556178108</timestart>
        <timefinish>1556178115</timefinish>
        <timemodified>1556178115</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103562">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058780">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556178117</timemodified>
              <steps>
                <step id="28945077">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178108</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134660</value>
                    </variable>
                  </response>
                </step>
                <step id="28945079">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556178113</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>71aa2f88200d3a7cdbff2701d09ec1a4</value>
                    </variable>
                  </response>
                </step>
                <step id="28945083">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556178115</timecreated>
                  <userid>3678</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071818">
        <userid>3680</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103116</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173597</timestart>
        <timefinish>1556174310</timefinish>
        <timemodified>1556174310</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103116">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058111">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174312</timemodified>
              <steps>
                <step id="28943375">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173597</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134345</value>
                    </variable>
                  </response>
                </step>
                <step id="28943646">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174308</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e0a6c5440b895df27ceb7c2bf4c25557</value>
                    </variable>
                  </response>
                </step>
                <step id="28943647">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174310</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071896">
        <userid>3680</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103194</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174501</timestart>
        <timefinish>1556175539</timefinish>
        <timemodified>1556175539</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103194">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058281">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175541</timemodified>
              <steps>
                <step id="28943703">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174501</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134409</value>
                    </variable>
                  </response>
                </step>
                <step id="28943989">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175536</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4e43c6a7af4dc1cf5b0bc22fabcb7000</value>
                    </variable>
                  </response>
                </step>
                <step id="28943990">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175539</timecreated>
                  <userid>3680</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071708">
        <userid>3681</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103006</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171650</timestart>
        <timefinish>1556173224</timefinish>
        <timemodified>1556173224</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103006">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058001">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556173224</timemodified>
              <steps>
                <step id="28943114">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171650</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134243</value>
                    </variable>
                  </response>
                </step>
                <step id="28943285">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173221</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ed8ca6038773bcbe77e588bba8aef4ed</value>
                    </variable>
                  </response>
                </step>
                <step id="28943287">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173224</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071837">
        <userid>3681</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103135</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173895</timestart>
        <timefinish>1556173909</timefinish>
        <timemodified>1556173909</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103135">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058130">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556173911</timemodified>
              <steps>
                <step id="28943435">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173895</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134363</value>
                    </variable>
                  </response>
                </step>
                <step id="28943440">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173906</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>db04beb138dfe03b4b11b27811aabcd7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943442">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173909</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071867">
        <userid>3681</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103165</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174204</timestart>
        <timefinish>1556174218</timefinish>
        <timemodified>1556174218</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103165">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058252">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556174220</timemodified>
              <steps>
                <step id="28943617">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174204</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134388</value>
                    </variable>
                  </response>
                </step>
                <step id="28943622">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174215</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d80688d1c03299afd5afb8580ceb7f10</value>
                    </variable>
                  </response>
                </step>
                <step id="28943624">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174218</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071887">
        <userid>3681</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103185</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174395</timestart>
        <timefinish>1556174403</timefinish>
        <timemodified>1556174403</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103185">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058272">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556174405</timemodified>
              <steps>
                <step id="28943682">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174395</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134403</value>
                    </variable>
                  </response>
                </step>
                <step id="28943685">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174401</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1ba9c988125e837484a4b3441517c9c3</value>
                    </variable>
                  </response>
                </step>
                <step id="28943687">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174403</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072064">
        <userid>3681</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103362</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176359</timestart>
        <timefinish>1556176371</timefinish>
        <timemodified>1556176371</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103362">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058479">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1a.jar</responsesummary>
              <timemodified>1556176374</timemodified>
              <steps>
                <step id="28944278">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176359</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134541</value>
                    </variable>
                  </response>
                </step>
                <step id="28944283">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176367</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f56e9601630be696004d66abdd396ba4</value>
                    </variable>
                  </response>
                </step>
                <step id="28944284">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176371</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072561">
        <userid>3681</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103859</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556182085</timestart>
        <timefinish>1556182101</timefinish>
        <timemodified>1556182101</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103859">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9059216">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercize1b.jar</responsesummary>
              <timemodified>1556182103</timemodified>
              <steps>
                <step id="28946539">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556182085</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134803</value>
                    </variable>
                  </response>
                </step>
                <step id="28946544">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556182098</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>846b570036377a5f2136c0027a7c4b2a</value>
                    </variable>
                  </response>
                </step>
                <step id="28946546">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556182101</timecreated>
                  <userid>3681</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071795">
        <userid>3688</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103093</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173292</timestart>
        <timefinish>1556174162</timefinish>
        <timemodified>1556174162</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103093">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058088">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174164</timemodified>
              <steps>
                <step id="28943320">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173292</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134325</value>
                    </variable>
                  </response>
                </step>
                <step id="28943602">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174158</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>4a5599bfbd8682fa11e1a5aea415704c</value>
                    </variable>
                  </response>
                </step>
                <step id="28943605">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174162</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071870">
        <userid>3688</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103168</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174230</timestart>
        <timefinish>1556174245</timefinish>
        <timemodified>1556174245</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103168">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058255">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174247</timemodified>
              <steps>
                <step id="28943625">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174230</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134390</value>
                    </variable>
                  </response>
                </step>
                <step id="28943626">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174241</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>34864e4d5410b8dd1c983e743b93b9da</value>
                    </variable>
                  </response>
                </step>
                <step id="28943628">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174245</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071894">
        <userid>3688</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103192</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174493</timestart>
        <timefinish>1556174517</timefinish>
        <timemodified>1556174517</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103192">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058279">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174519</timemodified>
              <steps>
                <step id="28943700">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174493</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134407</value>
                    </variable>
                  </response>
                </step>
                <step id="28943702">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174498</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b7d106b281d2b1702484c4db22432cd9</value>
                    </variable>
                  </response>
                </step>
                <step id="28943709">
                  <sequencenumber>2</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174514</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ff565e988abe543a5bcf346492873191</value>
                    </variable>
                  </response>
                </step>
                <step id="28943712">
                  <sequencenumber>3</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174517</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071958">
        <userid>3688</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103256</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175160</timestart>
        <timefinish>1556175171</timefinish>
        <timemodified>1556175171</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103256">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058347">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175173</timemodified>
              <steps>
                <step id="28943912">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175160</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134462</value>
                    </variable>
                  </response>
                </step>
                <step id="28943913">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175169</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>57f671e527c790000701189d0bda0ba4</value>
                    </variable>
                  </response>
                </step>
                <step id="28943915">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175171</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072052">
        <userid>3688</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103350</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176248</timestart>
        <timefinish>1556176260</timefinish>
        <timemodified>1556176260</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103350">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058464">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176262</timemodified>
              <steps>
                <step id="28944234">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176248</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134533</value>
                    </variable>
                  </response>
                </step>
                <step id="28944237">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176257</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2f8f7e2ffefddffdc0aa7e3b0f1e531c</value>
                    </variable>
                  </response>
                </step>
                <step id="28944242">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176260</timecreated>
                  <userid>3688</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071780">
        <userid>3696</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103078</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173255</timestart>
        <timefinish>1556175010</timefinish>
        <timemodified>1556175010</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103078">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058073">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175012</timemodified>
              <steps>
                <step id="28943301">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173255</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134311</value>
                    </variable>
                  </response>
                </step>
                <step id="28943854">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175006</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>2e130c19da8f9ee6476ffab47ab06fae</value>
                    </variable>
                  </response>
                </step>
                <step id="28943857">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175010</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071944">
        <userid>3696</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103242</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175033</timestart>
        <timefinish>1556175825</timefinish>
        <timemodified>1556175825</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103242">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058333">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175826</timemodified>
              <steps>
                <step id="28943868">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175033</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134449</value>
                    </variable>
                  </response>
                </step>
                <step id="28944043">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175821</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>a419758275b969dd69b274d2eb467364</value>
                    </variable>
                  </response>
                </step>
                <step id="28944044">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175825</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071997">
        <userid>3696</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103295</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175835</timestart>
        <timefinish>1556176404</timefinish>
        <timemodified>1556176404</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103295">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058387">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176406</timemodified>
              <steps>
                <step id="28944049">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175835</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134495</value>
                    </variable>
                  </response>
                </step>
                <step id="28944295">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176400</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>54fcb2bec5bead011fd19dc5e156e159</value>
                    </variable>
                  </response>
                </step>
                <step id="28944300">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556176404</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072072">
        <userid>3696</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103370</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176418</timestart>
        <timefinish>1556177150</timefinish>
        <timemodified>1556177150</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103370">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058490">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177152</timemodified>
              <steps>
                <step id="28944306">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176418</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134545</value>
                    </variable>
                  </response>
                </step>
                <step id="28944645">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177144</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>0b6c169dcd7eeae8be5bfa83e26539f5</value>
                    </variable>
                  </response>
                </step>
                <step id="28944648">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177150</timecreated>
                  <userid>3696</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071687">
        <userid>3701</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1102985</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171442</timestart>
        <timefinish>1556172730</timefinish>
        <timemodified>1556172730</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1102985">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9057980">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise.jar</responsesummary>
              <timemodified>1556172732</timemodified>
              <steps>
                <step id="28943091">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171442</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134222</value>
                    </variable>
                  </response>
                </step>
                <step id="28943204">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172728</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>423af6caa0b1b2f9e7ee9a4faa1cb7d6</value>
                    </variable>
                  </response>
                </step>
                <step id="28943207">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172730</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071751">
        <userid>3701</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103049</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172846</timestart>
        <timefinish>1556172854</timefinish>
        <timemodified>1556172854</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103049">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058044">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172856</timemodified>
              <steps>
                <step id="28943224">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172846</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134284</value>
                    </variable>
                  </response>
                </step>
                <step id="28943226">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172851</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1bc2311b56aac93058a46dd5293f7b18</value>
                    </variable>
                  </response>
                </step>
                <step id="28943228">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172854</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071772">
        <userid>3701</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103070</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173221</timestart>
        <timefinish>1556173230</timefinish>
        <timemodified>1556173230</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103070">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058065">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173232</timemodified>
              <steps>
                <step id="28943286">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173221</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134303</value>
                    </variable>
                  </response>
                </step>
                <step id="28943289">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173228</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>d7b76a16beb8a3941224a09b7341b433</value>
                    </variable>
                  </response>
                </step>
                <step id="28943294">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173230</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071812">
        <userid>3701</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103110</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173500</timestart>
        <timefinish>1556173508</timefinish>
        <timemodified>1556173508</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103110">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058105">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173510</timemodified>
              <steps>
                <step id="28943354">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173500</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134340</value>
                    </variable>
                  </response>
                </step>
                <step id="28943356">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173505</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e4a6b50f9746649b13c8b9da9365c0ca</value>
                    </variable>
                  </response>
                </step>
                <step id="28943358">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556173508</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071827">
        <userid>3701</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103125</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173702</timestart>
        <timefinish>1556173709</timefinish>
        <timemodified>1556173709</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103125">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058120">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556173711</timemodified>
              <steps>
                <step id="28943402">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173702</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134354</value>
                    </variable>
                  </response>
                </step>
                <step id="28943404">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173707</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1771a9cca65cb5d82c4d47662da12071</value>
                    </variable>
                  </response>
                </step>
                <step id="28943405">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556173709</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071851">
        <userid>3701</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103149</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174036</timestart>
        <timefinish>1556174045</timefinish>
        <timemodified>1556174045</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103149">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058144">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174047</timemodified>
              <steps>
                <step id="28943483">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174036</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134376</value>
                    </variable>
                  </response>
                </step>
                <step id="28943485">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174043</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>252b33a2771b515eb5b72ffdd35a5b01</value>
                    </variable>
                  </response>
                </step>
                <step id="28943486">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174045</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071859">
        <userid>3701</userid>
        <attemptnum>7</attemptnum>
        <uniqueid>1103157</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174083</timestart>
        <timefinish>1556174894</timefinish>
        <timemodified>1556174894</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103157">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058243">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174896</timemodified>
              <steps>
                <step id="28943589">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174083</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134381</value>
                    </variable>
                  </response>
                </step>
                <step id="28943820">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174892</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>dc1d76d3fe64cd8b67b47902fe0bd8a0</value>
                    </variable>
                  </response>
                </step>
                <step id="28943822">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556174894</timecreated>
                  <userid>3701</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071785">
        <userid>3708</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103083</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173273</timestart>
        <timefinish>1556174746</timefinish>
        <timemodified>1556174746</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103083">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058078">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174747</timemodified>
              <steps>
                <step id="28943309">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173273</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134315</value>
                    </variable>
                  </response>
                </step>
                <step id="28943785">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174743</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8c9fba877ca51022e33e61ddeb8bdb9a</value>
                    </variable>
                  </response>
                </step>
                <step id="28943786">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174746</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071919">
        <userid>3708</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103217</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174761</timestart>
        <timefinish>1556174857</timefinish>
        <timemodified>1556174857</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103217">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058304">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174858</timemodified>
              <steps>
                <step id="28943790">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174761</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134430</value>
                    </variable>
                  </response>
                </step>
                <step id="28943812">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174855</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f23bc0a5e7ec719657cb82b78d03f787</value>
                    </variable>
                  </response>
                </step>
                <step id="28943813">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174857</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071931">
        <userid>3708</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103229</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174866</timestart>
        <timefinish>1556175103</timefinish>
        <timemodified>1556175103</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103229">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058316">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175105</timemodified>
              <steps>
                <step id="28943814">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174866</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134440</value>
                    </variable>
                  </response>
                </step>
                <step id="28943890">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175100</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>42b992ae75c94e2f0d1ec1bb3da71010</value>
                    </variable>
                  </response>
                </step>
                <step id="28943892">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556175103</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071953">
        <userid>3708</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103251</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175113</timestart>
        <timefinish>1556175555</timefinish>
        <timemodified>1556175555</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103251">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058342">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175557</timemodified>
              <steps>
                <step id="28943899">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175113</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134457</value>
                    </variable>
                  </response>
                </step>
                <step id="28943991">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175552</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3be9464f8d3741554df7db39ed828432</value>
                    </variable>
                  </response>
                </step>
                <step id="28943992">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175555</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071989">
        <userid>3708</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103287</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175695</timestart>
        <timefinish>1556176932</timefinish>
        <timemodified>1556176932</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103287">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058379">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176936</timemodified>
              <steps>
                <step id="28944026">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175695</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134488</value>
                    </variable>
                  </response>
                </step>
                <step id="28944512">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176929</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ed41fef7c6854e25392e20f30a9110ab</value>
                    </variable>
                  </response>
                </step>
                <step id="28944516">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176932</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072132">
        <userid>3708</userid>
        <attemptnum>6</attemptnum>
        <uniqueid>1103430</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556177047</timestart>
        <timefinish>1556177716</timefinish>
        <timemodified>1556177716</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103430">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058581">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177718</timemodified>
              <steps>
                <step id="28944551">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177047</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134582</value>
                    </variable>
                  </response>
                </step>
                <step id="28944934">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177714</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ff753e43e2cb1a53c990caf631330b4b</value>
                    </variable>
                  </response>
                </step>
                <step id="28944938">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177716</timecreated>
                  <userid>3708</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071769">
        <userid>3709</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103067</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173184</timestart>
        <timefinish>1556174009</timefinish>
        <timemodified>1556174009</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103067">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058062">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556174011</timemodified>
              <steps>
                <step id="28943282">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173184</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134300</value>
                    </variable>
                  </response>
                </step>
                <step id="28943468">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174007</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>73e96996349542796b39fcd32d239828</value>
                    </variable>
                  </response>
                </step>
                <step id="28943472">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174009</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071907">
        <userid>3709</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103205</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174622</timestart>
        <timefinish>1556174630</timefinish>
        <timemodified>1556174630</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103205">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058292">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556174632</timemodified>
              <steps>
                <step id="28943743">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174622</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134420</value>
                    </variable>
                  </response>
                </step>
                <step id="28943745">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174627</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>87c085efb938d75e0d93e6c9db4991b2</value>
                    </variable>
                  </response>
                </step>
                <step id="28943746">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174630</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071911">
        <userid>3709</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103209</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174640</timestart>
        <timefinish>1556175069</timefinish>
        <timemodified>1556175069</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103209">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058296">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1.jar</responsesummary>
              <timemodified>1556175072</timemodified>
              <steps>
                <step id="28943750">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174640</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134424</value>
                    </variable>
                  </response>
                </step>
                <step id="28943878">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175065</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e28309f2c7087f98cb730a40d9da3c88</value>
                    </variable>
                  </response>
                </step>
                <step id="28943880">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175069</timecreated>
                  <userid>3709</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071712">
        <userid>3714</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103010</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171654</timestart>
        <timefinish>1556172231</timefinish>
        <timemodified>1556172231</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103010">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058005">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172231</timemodified>
              <steps>
                <step id="28943118">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171654</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134247</value>
                    </variable>
                  </response>
                </step>
                <step id="28943135">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172215</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>394ce0a2d44da5e04262f9eb45bfb9e4</value>
                    </variable>
                  </response>
                </step>
                <step id="28943136">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172231</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071722">
        <userid>3714</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103020</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172251</timestart>
        <timefinish>1556172358</timefinish>
        <timemodified>1556172358</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103020">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058015">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172360</timemodified>
              <steps>
                <step id="28943137">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172251</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134256</value>
                    </variable>
                  </response>
                </step>
                <step id="28943143">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172356</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e1b8b73b6a1cf2bb0e18a346d17438fe</value>
                    </variable>
                  </response>
                </step>
                <step id="28943145">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172358</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071726">
        <userid>3714</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103024</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172373</timestart>
        <timefinish>1556172866</timefinish>
        <timemodified>1556172866</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103024">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058019">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172868</timemodified>
              <steps>
                <step id="28943151">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172373</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134260</value>
                    </variable>
                  </response>
                </step>
                <step id="28943232">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172864</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>3a084ee6593c9eb88efb2d798f5b4a7b</value>
                    </variable>
                  </response>
                </step>
                <step id="28943233">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556172866</timecreated>
                  <userid>3714</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071797">
        <userid>3723</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103095</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173312</timestart>
        <timefinish>1556174512</timefinish>
        <timemodified>1556174512</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103095">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058090">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174514</timemodified>
              <steps>
                <step id="28943324">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173312</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134327</value>
                    </variable>
                  </response>
                </step>
                <step id="28943706">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174509</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bd41dff698736e9bcc4889bd2493adb8</value>
                    </variable>
                  </response>
                </step>
                <step id="28943708">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174512</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071899">
        <userid>3723</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103197</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174530</timestart>
        <timefinish>1556176043</timefinish>
        <timemodified>1556176043</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103197">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058284">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176045</timemodified>
              <steps>
                <step id="28943714">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174530</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134412</value>
                    </variable>
                  </response>
                </step>
                <step id="28944146">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176040</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>bd41dff698736e9bcc4889bd2493adb8</value>
                    </variable>
                  </response>
                </step>
                <step id="28944148">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556176043</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072026">
        <userid>3723</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103324</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176056</timestart>
        <timefinish>1556176107</timefinish>
        <timemodified>1556176107</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103324">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058435">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176109</timemodified>
              <steps>
                <step id="28944154">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176056</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134515</value>
                    </variable>
                  </response>
                </step>
                <step id="28944170">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176093</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>af00283b746a3231e6ba25d122f6d764</value>
                    </variable>
                  </response>
                </step>
                <step id="28944180">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556176107</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072035">
        <userid>3723</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103333</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176119</timestart>
        <timefinish>1556177353</timefinish>
        <timemodified>1556177353</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103333">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058445">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556177355</timemodified>
              <steps>
                <step id="28944183">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176119</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134522</value>
                    </variable>
                  </response>
                </step>
                <step id="28944755">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556177350</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>f325357ef32d6bbab822d791f0dc3ed0</value>
                    </variable>
                  </response>
                </step>
                <step id="28944773">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556177353</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1084302">
        <userid>3723</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1115621</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1557992292</timestart>
        <timefinish>1557992302</timefinish>
        <timemodified>1557992302</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1115621">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9177044">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>(ファイルなし)</responsesummary>
              <timemodified>1557992303</timemodified>
              <steps>
                <step id="29325092">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1557992292</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>136962</value>
                    </variable>
                  </response>
                </step>
                <step id="29325117">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1557992299</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value></value>
                    </variable>
                  </response>
                </step>
                <step id="29325118">
                  <sequencenumber>2</sequencenumber>
                  <state>gaveup</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1557992302</timecreated>
                  <userid>3723</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071793">
        <userid>3726</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103091</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173283</timestart>
        <timefinish>1556174144</timefinish>
        <timemodified>1556174144</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103091">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058086">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174144</timemodified>
              <steps>
                <step id="28943318">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173283</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134323</value>
                    </variable>
                  </response>
                </step>
                <step id="28943598">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174141</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>e0029d8516a3290507da82e27cff37a1</value>
                    </variable>
                  </response>
                </step>
                <step id="28943599">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556174144</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071864">
        <userid>3726</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103162</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174180</timestart>
        <timefinish>1556174303</timefinish>
        <timemodified>1556174303</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103162">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058249">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174306</timemodified>
              <steps>
                <step id="28943611">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174180</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134385</value>
                    </variable>
                  </response>
                </step>
                <step id="28943643">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174301</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7625e808b16f7c7182b6baeb38dd6a00</value>
                    </variable>
                  </response>
                </step>
                <step id="28943645">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174303</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071881">
        <userid>3726</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103179</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174353</timestart>
        <timefinish>1556174872</timefinish>
        <timemodified>1556174872</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103179">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058266">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556174874</timemodified>
              <steps>
                <step id="28943662">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174353</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134397</value>
                    </variable>
                  </response>
                </step>
                <step id="28943815">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174869</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>86293d0904b96c326580117afeb07b2b</value>
                    </variable>
                  </response>
                </step>
                <step id="28943816">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556174872</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071932">
        <userid>3726</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103230</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556174897</timestart>
        <timefinish>1556176587</timefinish>
        <timemodified>1556176587</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103230">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058317">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176587</timemodified>
              <steps>
                <step id="28943823">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174897</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134441</value>
                    </variable>
                  </response>
                </step>
                <step id="28944367">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176584</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>dd8e8d193914f8347bc422fbd1c11d4d</value>
                    </variable>
                  </response>
                </step>
                <step id="28944369">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556176587</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072090">
        <userid>3726</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103388</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176599</timestart>
        <timefinish>1556176636</timefinish>
        <timemodified>1556176636</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103388">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058514">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556176638</timemodified>
              <steps>
                <step id="28944370">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176599</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134554</value>
                    </variable>
                  </response>
                </step>
                <step id="28944382">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176634</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>c61f1149c7d63c7abc47a2d7ba5d82cc</value>
                    </variable>
                  </response>
                </step>
                <step id="28944383">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176636</timecreated>
                  <userid>3726</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071715">
        <userid>3728</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103013</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556171662</timestart>
        <timefinish>1556172445</timefinish>
        <timemodified>1556172445</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103013">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058008">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172447</timemodified>
              <steps>
                <step id="28943121">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556171662</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134250</value>
                    </variable>
                  </response>
                </step>
                <step id="28943158">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172443</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>23796be4277f785fb180b28aba135a07</value>
                    </variable>
                  </response>
                </step>
                <step id="28943160">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedwrong</state>
                  <fraction>0.0000000</fraction>
                  <timecreated>1556172445</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071730">
        <userid>3728</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103028</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172457</timestart>
        <timefinish>1556172767</timefinish>
        <timemodified>1556172767</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103028">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058023">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556172769</timemodified>
              <steps>
                <step id="28943163">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172457</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134264</value>
                    </variable>
                  </response>
                </step>
                <step id="28943215">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172763</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>9c25463c1d6aca428690e5c6075f2fb7</value>
                    </variable>
                  </response>
                </step>
                <step id="28943217">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556172767</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071748">
        <userid>3728</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103046</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556172779</timestart>
        <timefinish>1556173261</timefinish>
        <timemodified>1556173261</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>0.00000</sumgrades>
        <question_usage id="1103046">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058041">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>(ファイルなし)</responsesummary>
              <timemodified>1556173261</timemodified>
              <steps>
                <step id="28943221">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556172779</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134282</value>
                    </variable>
                  </response>
                </step>
                <step id="28943303">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173258</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value></value>
                    </variable>
                  </response>
                </step>
                <step id="28943306">
                  <sequencenumber>2</sequencenumber>
                  <state>gaveup</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173261</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071788">
        <userid>3728</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103086</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173279</timestart>
        <timefinish>1556175151</timefinish>
        <timemodified>1556175151</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103086">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058081">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175153</timemodified>
              <steps>
                <step id="28943313">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173279</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134318</value>
                    </variable>
                  </response>
                </step>
                <step id="28943906">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175146</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>75e4bad320ba4fa6055ac776961a011a</value>
                    </variable>
                  </response>
                </step>
                <step id="28943909">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175151</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071982">
        <userid>3728</userid>
        <attemptnum>5</attemptnum>
        <uniqueid>1103280</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175593</timestart>
        <timefinish>1556175834</timefinish>
        <timemodified>1556175834</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103280">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058372">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>exercise1a.jar</responsesummary>
              <timemodified>1556175836</timemodified>
              <steps>
                <step id="28943997">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175593</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134482</value>
                    </variable>
                  </response>
                </step>
                <step id="28944047">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175830</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>7a7481f2564583f9e913070371dd1e97</value>
                    </variable>
                  </response>
                </step>
                <step id="28944051">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556175834</timecreated>
                  <userid>3728</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071811">
        <userid>3734</userid>
        <attemptnum>1</attemptnum>
        <uniqueid>1103109</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556173485</timestart>
        <timefinish>1556174718</timefinish>
        <timemodified>1556174718</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>1.98000</sumgrades>
        <question_usage id="1103109">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058104">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556174721</timemodified>
              <steps>
                <step id="28943353">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556173485</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134339</value>
                    </variable>
                  </response>
                </step>
                <step id="28943775">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556174715</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>1e4172d1978fe176f3e87c38c1f166ee</value>
                    </variable>
                  </response>
                </step>
                <step id="28943777">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.1980000</fraction>
                  <timecreated>1556174718</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071984">
        <userid>3734</userid>
        <attemptnum>2</attemptnum>
        <uniqueid>1103282</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175620</timestart>
        <timefinish>1556175635</timefinish>
        <timemodified>1556175635</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103282">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058374">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175637</timemodified>
              <steps>
                <step id="28944000">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175620</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134483</value>
                    </variable>
                  </response>
                </step>
                <step id="28944001">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175633</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>8f4c0d1ecd76dfb91ff609f488749a99</value>
                    </variable>
                  </response>
                </step>
                <step id="28944002">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175635</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1071991">
        <userid>3734</userid>
        <attemptnum>3</attemptnum>
        <uniqueid>1103289</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556175776</timestart>
        <timefinish>1556175789</timefinish>
        <timemodified>1556175789</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>4.02000</sumgrades>
        <question_usage id="1103289">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058381">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556175791</timemodified>
              <steps>
                <step id="28944031">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175776</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134489</value>
                    </variable>
                  </response>
                </step>
                <step id="28944033">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556175785</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>b240d74ea38d5224735fdd7153952bef</value>
                    </variable>
                  </response>
                </step>
                <step id="28944035">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedpartial</state>
                  <fraction>0.4020000</fraction>
                  <timecreated>1556175789</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
      <attempt id="1072125">
        <userid>3734</userid>
        <attemptnum>4</attemptnum>
        <uniqueid>1103423</uniqueid>
        <layout>1,0</layout>
        <currentpage>0</currentpage>
        <preview>0</preview>
        <state>finished</state>
        <timestart>1556176976</timestart>
        <timefinish>1556176990</timefinish>
        <timemodified>1556176990</timemodified>
        <timemodifiedoffline>0</timemodifiedoffline>
        <timecheckstate>$@NULL@$</timecheckstate>
        <sumgrades>10.00000</sumgrades>
        <question_usage id="1103423">
          <component>mod_quiz</component>
          <preferredbehaviour>deferredfeedback</preferredbehaviour>
          <question_attempts>
            <question_attempt id="9058573">
              <slot>1</slot>
              <behaviour>deferredfeedback</behaviour>
              <questionid>219047</questionid>
              <variant>1</variant>
              <maxmark>10.0000000</maxmark>
              <minfraction>0.0000000</minfraction>
              <maxfraction>1.0000000</maxfraction>
              <flagged>0</flagged>
              <questionsummary>課題：関数の実装と課題の進め方

JavaやCには平方根を求める関数が元々用意されているが、この課題では下記のアルゴリズムで平方根を求めるメソッド(関数)を実装することで、Java言語によるメソッドの実装方法、動作確認やテストの方法について学習する。

課題の概要

平方根(の近似値)を求めるアルゴリズムはいくつかあるが、ここではごく簡単に実装でき、短い計算時間でそれなりの精度の値が求められる方法を用いる。

具体的に、正数値 [s] の平方根を求める際、初期値として適当な正数値 [x_0] を用意し、

[x_{n+1} = \frac{x_n + \frac{s}{x_n}}{2}]

の計算を繰り返し、ある程度、値が収束した時点で計算を終えるというものである。

手順

	* 新たにexercise1パッケージを作成する。（srcを右クリックし、New→Package）

	* exercise1パッケージにSquareRootクラスを作成し、空のmainメソッドを作る

	* クラス作成時にmainメソッドも作るようにチェックを入れると良い
	* クラス名は大文字小文字の違いも含めて正確に作ること
	* 作り間違えた場合はクラスを削除して作り直すことも可能だが、クラス名だけの間違いであれば、クラス名右クリック→Refactorメニュー→Renameでクラス名を変更するとよい（Eclipse上でプロジェクト, パッケージ, クラス, メソッド, 変数などの名前を変える際は、変更ミスの発生を抑えるためにRefactorメニューのRenameを使うと良い）
	* 以下は空のmainメソッドまで実装した例である。
[SquareRoot]

	* 次に平方根を求めるメソッドの枠組みを用意する。メソッドの名前はcalcSQRootとし、引数は整数だけを受け取り、戻り値としてdouble型の実数を返すものとする。

	* メソッドを宣言するときにはその修飾子として先頭に現時点では public static を付けておく。これらの修飾子の意味はおいおい扱うが、気になる人は教科書参考書等で確認してみると良い。
	* 戻り値の型を宣言したとき、その型に対応した値を返すreturnがないとJavaはコンパイルエラーになってしまう。戻り値の型がdouble型の場合で、まだ値を返せるまで実装できていないときは仮に return 0.0; としておこう。
	* この時点で最初の課題提出をし、点数が0点ではないことを確認する

	* [x_0]を1とし、[x_1]だけ求めて返すよう実装しよう。

	* メソッド内でこの種の計算を行って値を返す際、適宜ローカル変数を宣言して計算途中の値や最終的な計算結果を代入などしてもよい。今回は[x_0]が1に固定で[x_1]を返すだけであるので、ローカル変数を一切宣言せずに
RETURN (引数と[X_0]から[X_1]を計算する式);
のようにreturn文1個だけで実装することも可能であるが、後で処理内容がより複雑になる可能性がある場合や、計算途中の値を確認用に表示させたい場合などを踏まえて、適宜ローカル変数を用いるとよい。例えば、
変数X0とX1を宣言
X0に1.0を代入
X1には引数とX0から計算した[X_1]を代入
RETURN X1;
とする実装方法があり得る。
	* 動作確認用にmainメソッドからcalcSQRootメソッドを呼び、その結果を出力する処理を実装し、実際に実行してみる。例えば、mainメソッドに以下のように実行すると、引数20を与えてcalcSQRootを実行し、その実行結果を表示することができる。
[main CalcSQR20]
	* この時点で2回目の課題提出をし、先の提出時よりも自動採点の点数が上がっていることを確認する。

	* [x_{10}]まで求めて返すように実装しよう。

	* 次のどの実装方法が適切か考えてみよう。（繰り返し回数を柔軟に変更できるのはどれか）

	* [x_1]を求める代入文、[x_2]を求める代入文、...、[x_{10}]を求める代入文と10個の代入文を列挙する
	* 上の10個をまとめたなが～い代入文を1個書く
	* forなどを用いた繰り返しを書く

	* メソッド実行中の[x_n]の値の変化が分かるようにSystem.out.printlnを入れて途中経過を表示させてみよう。例えば 20 の平方根をこのアルゴリズムで求める経過は以下のように表示されるはずである。
[Sqrt20 Results]
	* 再び実行して、試してみる。20だけでなく、いくつかの値を試してみると良い
	* この時点で3回目の課題提出

提出

SquareRootクラスだけが含まれるようにexercise1a.jarという名前でエクスポートしたものを以下にアップロードして提出すること
</questionsummary>
              <rightanswer>$@NULL@$</rightanswer>
              <responsesummary>SquareRoot.jar</responsesummary>
              <timemodified>1556176992</timemodified>
              <steps>
                <step id="28944527">
                  <sequencenumber>0</sequencenumber>
                  <state>todo</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176976</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>_upcheckerattempt</name>
                      <value>134579</value>
                    </variable>
                  </response>
                </step>
                <step id="28944529">
                  <sequencenumber>1</sequencenumber>
                  <state>complete</state>
                  <fraction>$@NULL@$</fraction>
                  <timecreated>1556176987</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>answer</name>
                      <value>ae8cb3b25f8dc1a6a62b097bd2d74094</value>
                    </variable>
                  </response>
                </step>
                <step id="28944533">
                  <sequencenumber>2</sequencenumber>
                  <state>gradedright</state>
                  <fraction>1.0000000</fraction>
                  <timecreated>1556176990</timecreated>
                  <userid>3734</userid>
                  <response>
                    <variable>
                      <name>-finish</name>
                      <value>1</value>
                    </variable>
                  </response>
                </step>
              </steps>
            </question_attempt>
          </question_attempts>
        </question_usage>
      </attempt>
    </attempts>
  </quiz>
</activity>